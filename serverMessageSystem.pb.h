// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serverMessageSystem.proto

#ifndef PROTOBUF_INCLUDED_serverMessageSystem_2eproto
#define PROTOBUF_INCLUDED_serverMessageSystem_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_serverMessageSystem_2eproto 

namespace protobuf_serverMessageSystem_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_serverMessageSystem_2eproto
namespace serverMessageSystem {
class ChartMessage;
class ChartMessageDefaultTypeInternal;
extern ChartMessageDefaultTypeInternal _ChartMessage_default_instance_;
class ClientConnectionToRoomReply;
class ClientConnectionToRoomReplyDefaultTypeInternal;
extern ClientConnectionToRoomReplyDefaultTypeInternal _ClientConnectionToRoomReply_default_instance_;
class ClientConnectionToRoomRequest;
class ClientConnectionToRoomRequestDefaultTypeInternal;
extern ClientConnectionToRoomRequestDefaultTypeInternal _ClientConnectionToRoomRequest_default_instance_;
class ClientRoomCreationReply;
class ClientRoomCreationReplyDefaultTypeInternal;
extern ClientRoomCreationReplyDefaultTypeInternal _ClientRoomCreationReply_default_instance_;
class ClientRoomCreationRequest;
class ClientRoomCreationRequestDefaultTypeInternal;
extern ClientRoomCreationRequestDefaultTypeInternal _ClientRoomCreationRequest_default_instance_;
class ClientWantedToEnterTheRoom;
class ClientWantedToEnterTheRoomDefaultTypeInternal;
extern ClientWantedToEnterTheRoomDefaultTypeInternal _ClientWantedToEnterTheRoom_default_instance_;
class CommonHeader;
class CommonHeaderDefaultTypeInternal;
extern CommonHeaderDefaultTypeInternal _CommonHeader_default_instance_;
class CreatedRoom;
class CreatedRoomDefaultTypeInternal;
extern CreatedRoomDefaultTypeInternal _CreatedRoom_default_instance_;
class DefaultMessage;
class DefaultMessageDefaultTypeInternal;
extern DefaultMessageDefaultTypeInternal _DefaultMessage_default_instance_;
class GameSettings;
class GameSettingsDefaultTypeInternal;
extern GameSettingsDefaultTypeInternal _GameSettings_default_instance_;
class GameType;
class GameTypeDefaultTypeInternal;
extern GameTypeDefaultTypeInternal _GameType_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class RoomCreationErrors;
class RoomCreationErrorsDefaultTypeInternal;
extern RoomCreationErrorsDefaultTypeInternal _RoomCreationErrors_default_instance_;
class ServerClientWantedToEnterTheRoomReply;
class ServerClientWantedToEnterTheRoomReplyDefaultTypeInternal;
extern ServerClientWantedToEnterTheRoomReplyDefaultTypeInternal _ServerClientWantedToEnterTheRoomReply_default_instance_;
class ServerInputQuery;
class ServerInputQueryDefaultTypeInternal;
extern ServerInputQueryDefaultTypeInternal _ServerInputQuery_default_instance_;
class ServerQueryOrderNotification;
class ServerQueryOrderNotificationDefaultTypeInternal;
extern ServerQueryOrderNotificationDefaultTypeInternal _ServerQueryOrderNotification_default_instance_;
class ServerQueryReply;
class ServerQueryReplyDefaultTypeInternal;
extern ServerQueryReplyDefaultTypeInternal _ServerQueryReply_default_instance_;
class ServerReportsClientIsLeaving;
class ServerReportsClientIsLeavingDefaultTypeInternal;
extern ServerReportsClientIsLeavingDefaultTypeInternal _ServerReportsClientIsLeaving_default_instance_;
class ServerReportsOpponentIsEnteringRoom;
class ServerReportsOpponentIsEnteringRoomDefaultTypeInternal;
extern ServerReportsOpponentIsEnteringRoomDefaultTypeInternal _ServerReportsOpponentIsEnteringRoom_default_instance_;
class ServerRoomChangesInSelectableList;
class ServerRoomChangesInSelectableListDefaultTypeInternal;
extern ServerRoomChangesInSelectableListDefaultTypeInternal _ServerRoomChangesInSelectableList_default_instance_;
class TimeSettings;
class TimeSettingsDefaultTypeInternal;
extern TimeSettingsDefaultTypeInternal _TimeSettings_default_instance_;
}  // namespace serverMessageSystem
namespace google {
namespace protobuf {
template<> ::serverMessageSystem::ChartMessage* Arena::CreateMaybeMessage<::serverMessageSystem::ChartMessage>(Arena*);
template<> ::serverMessageSystem::ClientConnectionToRoomReply* Arena::CreateMaybeMessage<::serverMessageSystem::ClientConnectionToRoomReply>(Arena*);
template<> ::serverMessageSystem::ClientConnectionToRoomRequest* Arena::CreateMaybeMessage<::serverMessageSystem::ClientConnectionToRoomRequest>(Arena*);
template<> ::serverMessageSystem::ClientRoomCreationReply* Arena::CreateMaybeMessage<::serverMessageSystem::ClientRoomCreationReply>(Arena*);
template<> ::serverMessageSystem::ClientRoomCreationRequest* Arena::CreateMaybeMessage<::serverMessageSystem::ClientRoomCreationRequest>(Arena*);
template<> ::serverMessageSystem::ClientWantedToEnterTheRoom* Arena::CreateMaybeMessage<::serverMessageSystem::ClientWantedToEnterTheRoom>(Arena*);
template<> ::serverMessageSystem::CommonHeader* Arena::CreateMaybeMessage<::serverMessageSystem::CommonHeader>(Arena*);
template<> ::serverMessageSystem::CreatedRoom* Arena::CreateMaybeMessage<::serverMessageSystem::CreatedRoom>(Arena*);
template<> ::serverMessageSystem::DefaultMessage* Arena::CreateMaybeMessage<::serverMessageSystem::DefaultMessage>(Arena*);
template<> ::serverMessageSystem::GameSettings* Arena::CreateMaybeMessage<::serverMessageSystem::GameSettings>(Arena*);
template<> ::serverMessageSystem::GameType* Arena::CreateMaybeMessage<::serverMessageSystem::GameType>(Arena*);
template<> ::serverMessageSystem::Player* Arena::CreateMaybeMessage<::serverMessageSystem::Player>(Arena*);
template<> ::serverMessageSystem::RoomCreationErrors* Arena::CreateMaybeMessage<::serverMessageSystem::RoomCreationErrors>(Arena*);
template<> ::serverMessageSystem::ServerClientWantedToEnterTheRoomReply* Arena::CreateMaybeMessage<::serverMessageSystem::ServerClientWantedToEnterTheRoomReply>(Arena*);
template<> ::serverMessageSystem::ServerInputQuery* Arena::CreateMaybeMessage<::serverMessageSystem::ServerInputQuery>(Arena*);
template<> ::serverMessageSystem::ServerQueryOrderNotification* Arena::CreateMaybeMessage<::serverMessageSystem::ServerQueryOrderNotification>(Arena*);
template<> ::serverMessageSystem::ServerQueryReply* Arena::CreateMaybeMessage<::serverMessageSystem::ServerQueryReply>(Arena*);
template<> ::serverMessageSystem::ServerReportsClientIsLeaving* Arena::CreateMaybeMessage<::serverMessageSystem::ServerReportsClientIsLeaving>(Arena*);
template<> ::serverMessageSystem::ServerReportsOpponentIsEnteringRoom* Arena::CreateMaybeMessage<::serverMessageSystem::ServerReportsOpponentIsEnteringRoom>(Arena*);
template<> ::serverMessageSystem::ServerRoomChangesInSelectableList* Arena::CreateMaybeMessage<::serverMessageSystem::ServerRoomChangesInSelectableList>(Arena*);
template<> ::serverMessageSystem::TimeSettings* Arena::CreateMaybeMessage<::serverMessageSystem::TimeSettings>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace serverMessageSystem {

enum RulesType {
  Automatic = 0,
  Manual = 1,
  RulesType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RulesType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RulesType_IsValid(int value);
const RulesType RulesType_MIN = Automatic;
const RulesType RulesType_MAX = Manual;
const int RulesType_ARRAYSIZE = RulesType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RulesType_descriptor();
inline const ::std::string& RulesType_Name(RulesType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RulesType_descriptor(), value);
}
inline bool RulesType_Parse(
    const ::std::string& name, RulesType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RulesType>(
    RulesType_descriptor(), name, value);
}
enum SubSystemID {
  CONNECTION_SUBSYSTEM = 0,
  GAME_ACTIONS_SUBSYSTEM = 1,
  GAME_NOTIFICATION_SUBSYSTEM = 2,
  CHART_SUBSYSTEM = 3,
  SubSystemID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SubSystemID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SubSystemID_IsValid(int value);
const SubSystemID SubSystemID_MIN = CONNECTION_SUBSYSTEM;
const SubSystemID SubSystemID_MAX = CHART_SUBSYSTEM;
const int SubSystemID_ARRAYSIZE = SubSystemID_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubSystemID_descriptor();
inline const ::std::string& SubSystemID_Name(SubSystemID value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubSystemID_descriptor(), value);
}
inline bool SubSystemID_Parse(
    const ::std::string& name, SubSystemID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubSystemID>(
    SubSystemID_descriptor(), name, value);
}
enum ConnectionSubSysCommandsID {
  SERVER_INPUT_QUERY_REQUEST = 0,
  SERVER_INPUT_QUERY_REPLY = 1,
  CLIENT_ROOM_CREATION_REQUEST = 2,
  CLIENT_ROOM_CREATION_REPLY = 3,
  CLIENT_CONNECTION_TO_ROOM_REQUEST = 4,
  CLIENT_CONNECTION_TO_ROOM_REPLY = 5,
  SERVER_REPORTS_OPPONENT_IS_ENTERING_ROOM = 6,
  SERVER_ROOM_CHANGES_IN_SELECTABLE_LIST = 7,
  CLIENT_WANTED_TO_ENTER_THE_ROOM = 8,
  SERVER_CLIENT_WANTED_TO_ENTER_THE_ROOM_REPLY = 9,
  SERVER_REPORTS_CLIENT_IS_LEAVING = 10,
  ConnectionSubSysCommandsID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionSubSysCommandsID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionSubSysCommandsID_IsValid(int value);
const ConnectionSubSysCommandsID ConnectionSubSysCommandsID_MIN = SERVER_INPUT_QUERY_REQUEST;
const ConnectionSubSysCommandsID ConnectionSubSysCommandsID_MAX = SERVER_REPORTS_CLIENT_IS_LEAVING;
const int ConnectionSubSysCommandsID_ARRAYSIZE = ConnectionSubSysCommandsID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionSubSysCommandsID_descriptor();
inline const ::std::string& ConnectionSubSysCommandsID_Name(ConnectionSubSysCommandsID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionSubSysCommandsID_descriptor(), value);
}
inline bool ConnectionSubSysCommandsID_Parse(
    const ::std::string& name, ConnectionSubSysCommandsID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionSubSysCommandsID>(
    ConnectionSubSysCommandsID_descriptor(), name, value);
}
enum ChartSubSysCommandsID {
  CHART_MESSAGE = 0,
  CHART_NOTIFICATION = 1,
  ChartSubSysCommandsID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChartSubSysCommandsID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChartSubSysCommandsID_IsValid(int value);
const ChartSubSysCommandsID ChartSubSysCommandsID_MIN = CHART_MESSAGE;
const ChartSubSysCommandsID ChartSubSysCommandsID_MAX = CHART_NOTIFICATION;
const int ChartSubSysCommandsID_ARRAYSIZE = ChartSubSysCommandsID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChartSubSysCommandsID_descriptor();
inline const ::std::string& ChartSubSysCommandsID_Name(ChartSubSysCommandsID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChartSubSysCommandsID_descriptor(), value);
}
inline bool ChartSubSysCommandsID_Parse(
    const ::std::string& name, ChartSubSysCommandsID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartSubSysCommandsID>(
    ChartSubSysCommandsID_descriptor(), name, value);
}
enum GameCreationRequest {
  JoinTheGame = 0,
  CreateTheGame = 1,
  GameCreationRequest_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameCreationRequest_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameCreationRequest_IsValid(int value);
const GameCreationRequest GameCreationRequest_MIN = JoinTheGame;
const GameCreationRequest GameCreationRequest_MAX = CreateTheGame;
const int GameCreationRequest_ARRAYSIZE = GameCreationRequest_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameCreationRequest_descriptor();
inline const ::std::string& GameCreationRequest_Name(GameCreationRequest value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameCreationRequest_descriptor(), value);
}
inline bool GameCreationRequest_Parse(
    const ::std::string& name, GameCreationRequest* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameCreationRequest>(
    GameCreationRequest_descriptor(), name, value);
}
// ===================================================================

class CommonHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.CommonHeader) */ {
 public:
  CommonHeader();
  virtual ~CommonHeader();

  CommonHeader(const CommonHeader& from);

  inline CommonHeader& operator=(const CommonHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonHeader(CommonHeader&& from) noexcept
    : CommonHeader() {
    *this = ::std::move(from);
  }

  inline CommonHeader& operator=(CommonHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonHeader* internal_default_instance() {
    return reinterpret_cast<const CommonHeader*>(
               &_CommonHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CommonHeader* other);
  friend void swap(CommonHeader& a, CommonHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonHeader* New() const final {
    return CreateMaybeMessage<CommonHeader>(NULL);
  }

  CommonHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonHeader& from);
  void MergeFrom(const CommonHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.SubSystemID subSystem = 1;
  void clear_subsystem();
  static const int kSubSystemFieldNumber = 1;
  ::serverMessageSystem::SubSystemID subsystem() const;
  void set_subsystem(::serverMessageSystem::SubSystemID value);

  // uint32 commandId = 2;
  void clear_commandid();
  static const int kCommandIdFieldNumber = 2;
  ::google::protobuf::uint32 commandid() const;
  void set_commandid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.CommonHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int subsystem_;
  ::google::protobuf::uint32 commandid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.TimeSettings) */ {
 public:
  TimeSettings();
  virtual ~TimeSettings();

  TimeSettings(const TimeSettings& from);

  inline TimeSettings& operator=(const TimeSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeSettings(TimeSettings&& from) noexcept
    : TimeSettings() {
    *this = ::std::move(from);
  }

  inline TimeSettings& operator=(TimeSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeSettings* internal_default_instance() {
    return reinterpret_cast<const TimeSettings*>(
               &_TimeSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TimeSettings* other);
  friend void swap(TimeSettings& a, TimeSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeSettings* New() const final {
    return CreateMaybeMessage<TimeSettings>(NULL);
  }

  TimeSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeSettings& from);
  void MergeFrom(const TimeSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 totalTimeToMove = 1;
  void clear_totaltimetomove();
  static const int kTotalTimeToMoveFieldNumber = 1;
  ::google::protobuf::uint32 totaltimetomove() const;
  void set_totaltimetomove(::google::protobuf::uint32 value);

  // uint32 timeToThink = 2;
  void clear_timetothink();
  static const int kTimeToThinkFieldNumber = 2;
  ::google::protobuf::uint32 timetothink() const;
  void set_timetothink(::google::protobuf::uint32 value);

  // uint32 timeForOpponentsDecision = 3;
  void clear_timeforopponentsdecision();
  static const int kTimeForOpponentsDecisionFieldNumber = 3;
  ::google::protobuf::uint32 timeforopponentsdecision() const;
  void set_timeforopponentsdecision(::google::protobuf::uint32 value);

  // uint32 diplomacyTime = 4;
  void clear_diplomacytime();
  static const int kDiplomacyTimeFieldNumber = 4;
  ::google::protobuf::uint32 diplomacytime() const;
  void set_diplomacytime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.TimeSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 totaltimetomove_;
  ::google::protobuf::uint32 timetothink_;
  ::google::protobuf::uint32 timeforopponentsdecision_;
  ::google::protobuf::uint32 diplomacytime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.GameType) */ {
 public:
  GameType();
  virtual ~GameType();

  GameType(const GameType& from);

  inline GameType& operator=(const GameType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameType(GameType&& from) noexcept
    : GameType() {
    *this = ::std::move(from);
  }

  inline GameType& operator=(GameType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameType* internal_default_instance() {
    return reinterpret_cast<const GameType*>(
               &_GameType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GameType* other);
  friend void swap(GameType& a, GameType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameType* New() const final {
    return CreateMaybeMessage<GameType>(NULL);
  }

  GameType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameType& from);
  void MergeFrom(const GameType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool hasAddonWildAxe = 1;
  void clear_hasaddonwildaxe();
  static const int kHasAddonWildAxeFieldNumber = 1;
  bool hasaddonwildaxe() const;
  void set_hasaddonwildaxe(bool value);

  // bool hasAddonClericalErrors = 2;
  void clear_hasaddonclericalerrors();
  static const int kHasAddonClericalErrorsFieldNumber = 2;
  bool hasaddonclericalerrors() const;
  void set_hasaddonclericalerrors(bool value);

  // .serverMessageSystem.RulesType rulesType = 3;
  void clear_rulestype();
  static const int kRulesTypeFieldNumber = 3;
  ::serverMessageSystem::RulesType rulestype() const;
  void set_rulestype(::serverMessageSystem::RulesType value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.GameType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool hasaddonwildaxe_;
  bool hasaddonclericalerrors_;
  int rulestype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.GameSettings) */ {
 public:
  GameSettings();
  virtual ~GameSettings();

  GameSettings(const GameSettings& from);

  inline GameSettings& operator=(const GameSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameSettings(GameSettings&& from) noexcept
    : GameSettings() {
    *this = ::std::move(from);
  }

  inline GameSettings& operator=(GameSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameSettings* internal_default_instance() {
    return reinterpret_cast<const GameSettings*>(
               &_GameSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GameSettings* other);
  friend void swap(GameSettings& a, GameSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameSettings* New() const final {
    return CreateMaybeMessage<GameSettings>(NULL);
  }

  GameSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameSettings& from);
  void MergeFrom(const GameSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.GameType gameType = 1;
  bool has_gametype() const;
  void clear_gametype();
  static const int kGameTypeFieldNumber = 1;
  private:
  const ::serverMessageSystem::GameType& _internal_gametype() const;
  public:
  const ::serverMessageSystem::GameType& gametype() const;
  ::serverMessageSystem::GameType* release_gametype();
  ::serverMessageSystem::GameType* mutable_gametype();
  void set_allocated_gametype(::serverMessageSystem::GameType* gametype);

  // .serverMessageSystem.TimeSettings timeSettings = 2;
  bool has_timesettings() const;
  void clear_timesettings();
  static const int kTimeSettingsFieldNumber = 2;
  private:
  const ::serverMessageSystem::TimeSettings& _internal_timesettings() const;
  public:
  const ::serverMessageSystem::TimeSettings& timesettings() const;
  ::serverMessageSystem::TimeSettings* release_timesettings();
  ::serverMessageSystem::TimeSettings* mutable_timesettings();
  void set_allocated_timesettings(::serverMessageSystem::TimeSettings* timesettings);

  // uint32 maximumNumberOfPlayers = 3;
  void clear_maximumnumberofplayers();
  static const int kMaximumNumberOfPlayersFieldNumber = 3;
  ::google::protobuf::uint32 maximumnumberofplayers() const;
  void set_maximumnumberofplayers(::google::protobuf::uint32 value);

  // bool settingsCorrectionAllowed = 4;
  void clear_settingscorrectionallowed();
  static const int kSettingsCorrectionAllowedFieldNumber = 4;
  bool settingscorrectionallowed() const;
  void set_settingscorrectionallowed(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.GameSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::GameType* gametype_;
  ::serverMessageSystem::TimeSettings* timesettings_;
  ::google::protobuf::uint32 maximumnumberofplayers_;
  bool settingscorrectionallowed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomCreationErrors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.RoomCreationErrors) */ {
 public:
  RoomCreationErrors();
  virtual ~RoomCreationErrors();

  RoomCreationErrors(const RoomCreationErrors& from);

  inline RoomCreationErrors& operator=(const RoomCreationErrors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomCreationErrors(RoomCreationErrors&& from) noexcept
    : RoomCreationErrors() {
    *this = ::std::move(from);
  }

  inline RoomCreationErrors& operator=(RoomCreationErrors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCreationErrors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomCreationErrors* internal_default_instance() {
    return reinterpret_cast<const RoomCreationErrors*>(
               &_RoomCreationErrors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RoomCreationErrors* other);
  friend void swap(RoomCreationErrors& a, RoomCreationErrors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomCreationErrors* New() const final {
    return CreateMaybeMessage<RoomCreationErrors>(NULL);
  }

  RoomCreationErrors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomCreationErrors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomCreationErrors& from);
  void MergeFrom(const RoomCreationErrors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreationErrors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool noFreeSlotsAvailable = 1;
  void clear_nofreeslotsavailable();
  static const int kNoFreeSlotsAvailableFieldNumber = 1;
  bool nofreeslotsavailable() const;
  void set_nofreeslotsavailable(bool value);

  // bool rulesAreNotSupported = 2;
  void clear_rulesarenotsupported();
  static const int kRulesAreNotSupportedFieldNumber = 2;
  bool rulesarenotsupported() const;
  void set_rulesarenotsupported(bool value);

  // bool incorrectSettings = 3;
  void clear_incorrectsettings();
  static const int kIncorrectSettingsFieldNumber = 3;
  bool incorrectsettings() const;
  void set_incorrectsettings(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.RoomCreationErrors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool nofreeslotsavailable_;
  bool rulesarenotsupported_;
  bool incorrectsettings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(NULL);
  }

  Player* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string playerName = 1;
  void clear_playername();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& playername() const;
  void set_playername(const ::std::string& value);
  #if LANG_CXX11
  void set_playername(::std::string&& value);
  #endif
  void set_playername(const char* value);
  void set_playername(const char* value, size_t size);
  ::std::string* mutable_playername();
  ::std::string* release_playername();
  void set_allocated_playername(::std::string* playername);

  // uint32 playerID = 2;
  void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr playername_;
  ::google::protobuf::uint32 playerid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreatedRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.CreatedRoom) */ {
 public:
  CreatedRoom();
  virtual ~CreatedRoom();

  CreatedRoom(const CreatedRoom& from);

  inline CreatedRoom& operator=(const CreatedRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatedRoom(CreatedRoom&& from) noexcept
    : CreatedRoom() {
    *this = ::std::move(from);
  }

  inline CreatedRoom& operator=(CreatedRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatedRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatedRoom* internal_default_instance() {
    return reinterpret_cast<const CreatedRoom*>(
               &_CreatedRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CreatedRoom* other);
  friend void swap(CreatedRoom& a, CreatedRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatedRoom* New() const final {
    return CreateMaybeMessage<CreatedRoom>(NULL);
  }

  CreatedRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreatedRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreatedRoom& from);
  void MergeFrom(const CreatedRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatedRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .serverMessageSystem.Player player = 5;
  int player_size() const;
  void clear_player();
  static const int kPlayerFieldNumber = 5;
  ::serverMessageSystem::Player* mutable_player(int index);
  ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::Player >*
      mutable_player();
  const ::serverMessageSystem::Player& player(int index) const;
  ::serverMessageSystem::Player* add_player();
  const ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::Player >&
      player() const;

  // string roomName = 2;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // uint32 roomID = 1;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // uint32 players = 3;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // uint32 maximumNumberOfPlayers = 4;
  void clear_maximumnumberofplayers();
  static const int kMaximumNumberOfPlayersFieldNumber = 4;
  ::google::protobuf::uint32 maximumnumberofplayers() const;
  void set_maximumnumberofplayers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.CreatedRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::Player > player_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 players_;
  ::google::protobuf::uint32 maximumnumberofplayers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerInputQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerInputQuery) */ {
 public:
  ServerInputQuery();
  virtual ~ServerInputQuery();

  ServerInputQuery(const ServerInputQuery& from);

  inline ServerInputQuery& operator=(const ServerInputQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInputQuery(ServerInputQuery&& from) noexcept
    : ServerInputQuery() {
    *this = ::std::move(from);
  }

  inline ServerInputQuery& operator=(ServerInputQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInputQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInputQuery* internal_default_instance() {
    return reinterpret_cast<const ServerInputQuery*>(
               &_ServerInputQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ServerInputQuery* other);
  friend void swap(ServerInputQuery& a, ServerInputQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInputQuery* New() const final {
    return CreateMaybeMessage<ServerInputQuery>(NULL);
  }

  ServerInputQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerInputQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerInputQuery& from);
  void MergeFrom(const ServerInputQuery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInputQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 3;
  void clear_clientname();
  static const int kClientNameFieldNumber = 3;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // string OsType = 4;
  void clear_ostype();
  static const int kOsTypeFieldNumber = 4;
  const ::std::string& ostype() const;
  void set_ostype(const ::std::string& value);
  #if LANG_CXX11
  void set_ostype(::std::string&& value);
  #endif
  void set_ostype(const char* value);
  void set_ostype(const char* value, size_t size);
  ::std::string* mutable_ostype();
  ::std::string* release_ostype();
  void set_allocated_ostype(::std::string* ostype);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerInputQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::google::protobuf::internal::ArenaStringPtr ostype_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerQueryReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerQueryReply) */ {
 public:
  ServerQueryReply();
  virtual ~ServerQueryReply();

  ServerQueryReply(const ServerQueryReply& from);

  inline ServerQueryReply& operator=(const ServerQueryReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerQueryReply(ServerQueryReply&& from) noexcept
    : ServerQueryReply() {
    *this = ::std::move(from);
  }

  inline ServerQueryReply& operator=(ServerQueryReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerQueryReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerQueryReply* internal_default_instance() {
    return reinterpret_cast<const ServerQueryReply*>(
               &_ServerQueryReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ServerQueryReply* other);
  friend void swap(ServerQueryReply& a, ServerQueryReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerQueryReply* New() const final {
    return CreateMaybeMessage<ServerQueryReply>(NULL);
  }

  ServerQueryReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerQueryReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerQueryReply& from);
  void MergeFrom(const ServerQueryReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerQueryReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serverName = 5;
  void clear_servername();
  static const int kServerNameFieldNumber = 5;
  const ::std::string& servername() const;
  void set_servername(const ::std::string& value);
  #if LANG_CXX11
  void set_servername(::std::string&& value);
  #endif
  void set_servername(const char* value);
  void set_servername(const char* value, size_t size);
  ::std::string* mutable_servername();
  ::std::string* release_servername();
  void set_allocated_servername(::std::string* servername);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool roomCreationAllowed = 3;
  void clear_roomcreationallowed();
  static const int kRoomCreationAllowedFieldNumber = 3;
  bool roomcreationallowed() const;
  void set_roomcreationallowed(bool value);

  // bool connectionToRoomAllowed = 4;
  void clear_connectiontoroomallowed();
  static const int kConnectionToRoomAllowedFieldNumber = 4;
  bool connectiontoroomallowed() const;
  void set_connectiontoroomallowed(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerQueryReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  bool roomcreationallowed_;
  bool connectiontoroomallowed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientRoomCreationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ClientRoomCreationRequest) */ {
 public:
  ClientRoomCreationRequest();
  virtual ~ClientRoomCreationRequest();

  ClientRoomCreationRequest(const ClientRoomCreationRequest& from);

  inline ClientRoomCreationRequest& operator=(const ClientRoomCreationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientRoomCreationRequest(ClientRoomCreationRequest&& from) noexcept
    : ClientRoomCreationRequest() {
    *this = ::std::move(from);
  }

  inline ClientRoomCreationRequest& operator=(ClientRoomCreationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRoomCreationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientRoomCreationRequest* internal_default_instance() {
    return reinterpret_cast<const ClientRoomCreationRequest*>(
               &_ClientRoomCreationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClientRoomCreationRequest* other);
  friend void swap(ClientRoomCreationRequest& a, ClientRoomCreationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientRoomCreationRequest* New() const final {
    return CreateMaybeMessage<ClientRoomCreationRequest>(NULL);
  }

  ClientRoomCreationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientRoomCreationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientRoomCreationRequest& from);
  void MergeFrom(const ClientRoomCreationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRoomCreationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 3;
  void clear_clientname();
  static const int kClientNameFieldNumber = 3;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // string roomName = 4;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 4;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.GameSettings gameSettings = 5;
  bool has_gamesettings() const;
  void clear_gamesettings();
  static const int kGameSettingsFieldNumber = 5;
  private:
  const ::serverMessageSystem::GameSettings& _internal_gamesettings() const;
  public:
  const ::serverMessageSystem::GameSettings& gamesettings() const;
  ::serverMessageSystem::GameSettings* release_gamesettings();
  ::serverMessageSystem::GameSettings* mutable_gamesettings();
  void set_allocated_gamesettings(::serverMessageSystem::GameSettings* gamesettings);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ClientRoomCreationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::serverMessageSystem::CommonHeader* header_;
  ::serverMessageSystem::GameSettings* gamesettings_;
  int connectioncmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientRoomCreationReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ClientRoomCreationReply) */ {
 public:
  ClientRoomCreationReply();
  virtual ~ClientRoomCreationReply();

  ClientRoomCreationReply(const ClientRoomCreationReply& from);

  inline ClientRoomCreationReply& operator=(const ClientRoomCreationReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientRoomCreationReply(ClientRoomCreationReply&& from) noexcept
    : ClientRoomCreationReply() {
    *this = ::std::move(from);
  }

  inline ClientRoomCreationReply& operator=(ClientRoomCreationReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRoomCreationReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientRoomCreationReply* internal_default_instance() {
    return reinterpret_cast<const ClientRoomCreationReply*>(
               &_ClientRoomCreationReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ClientRoomCreationReply* other);
  friend void swap(ClientRoomCreationReply& a, ClientRoomCreationReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientRoomCreationReply* New() const final {
    return CreateMaybeMessage<ClientRoomCreationReply>(NULL);
  }

  ClientRoomCreationReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientRoomCreationReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientRoomCreationReply& from);
  void MergeFrom(const ClientRoomCreationReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientRoomCreationReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.RoomCreationErrors roomCreationErrors = 6;
  bool has_roomcreationerrors() const;
  void clear_roomcreationerrors();
  static const int kRoomCreationErrorsFieldNumber = 6;
  private:
  const ::serverMessageSystem::RoomCreationErrors& _internal_roomcreationerrors() const;
  public:
  const ::serverMessageSystem::RoomCreationErrors& roomcreationerrors() const;
  ::serverMessageSystem::RoomCreationErrors* release_roomcreationerrors();
  ::serverMessageSystem::RoomCreationErrors* mutable_roomcreationerrors();
  void set_allocated_roomcreationerrors(::serverMessageSystem::RoomCreationErrors* roomcreationerrors);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool connectionAllowed = 3;
  void clear_connectionallowed();
  static const int kConnectionAllowedFieldNumber = 3;
  bool connectionallowed() const;
  void set_connectionallowed(bool value);

  // uint32 slotID = 4;
  void clear_slotid();
  static const int kSlotIDFieldNumber = 4;
  ::google::protobuf::uint32 slotid() const;
  void set_slotid(::google::protobuf::uint32 value);

  // uint32 freeSlotsLeft = 5;
  void clear_freeslotsleft();
  static const int kFreeSlotsLeftFieldNumber = 5;
  ::google::protobuf::uint32 freeslotsleft() const;
  void set_freeslotsleft(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ClientRoomCreationReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::CommonHeader* header_;
  ::serverMessageSystem::RoomCreationErrors* roomcreationerrors_;
  int connectioncmdid_;
  bool connectionallowed_;
  ::google::protobuf::uint32 slotid_;
  ::google::protobuf::uint32 freeslotsleft_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientConnectionToRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ClientConnectionToRoomRequest) */ {
 public:
  ClientConnectionToRoomRequest();
  virtual ~ClientConnectionToRoomRequest();

  ClientConnectionToRoomRequest(const ClientConnectionToRoomRequest& from);

  inline ClientConnectionToRoomRequest& operator=(const ClientConnectionToRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientConnectionToRoomRequest(ClientConnectionToRoomRequest&& from) noexcept
    : ClientConnectionToRoomRequest() {
    *this = ::std::move(from);
  }

  inline ClientConnectionToRoomRequest& operator=(ClientConnectionToRoomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConnectionToRoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientConnectionToRoomRequest* internal_default_instance() {
    return reinterpret_cast<const ClientConnectionToRoomRequest*>(
               &_ClientConnectionToRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ClientConnectionToRoomRequest* other);
  friend void swap(ClientConnectionToRoomRequest& a, ClientConnectionToRoomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientConnectionToRoomRequest* New() const final {
    return CreateMaybeMessage<ClientConnectionToRoomRequest>(NULL);
  }

  ClientConnectionToRoomRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientConnectionToRoomRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientConnectionToRoomRequest& from);
  void MergeFrom(const ClientConnectionToRoomRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConnectionToRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 3;
  void clear_clientname();
  static const int kClientNameFieldNumber = 3;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool connectToAnyRoom = 4;
  void clear_connecttoanyroom();
  static const int kConnectToAnyRoomFieldNumber = 4;
  bool connecttoanyroom() const;
  void set_connecttoanyroom(bool value);

  // bool agreeToWait = 5;
  void clear_agreetowait();
  static const int kAgreeToWaitFieldNumber = 5;
  bool agreetowait() const;
  void set_agreetowait(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ClientConnectionToRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  bool connecttoanyroom_;
  bool agreetowait_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientConnectionToRoomReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ClientConnectionToRoomReply) */ {
 public:
  ClientConnectionToRoomReply();
  virtual ~ClientConnectionToRoomReply();

  ClientConnectionToRoomReply(const ClientConnectionToRoomReply& from);

  inline ClientConnectionToRoomReply& operator=(const ClientConnectionToRoomReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientConnectionToRoomReply(ClientConnectionToRoomReply&& from) noexcept
    : ClientConnectionToRoomReply() {
    *this = ::std::move(from);
  }

  inline ClientConnectionToRoomReply& operator=(ClientConnectionToRoomReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConnectionToRoomReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientConnectionToRoomReply* internal_default_instance() {
    return reinterpret_cast<const ClientConnectionToRoomReply*>(
               &_ClientConnectionToRoomReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ClientConnectionToRoomReply* other);
  friend void swap(ClientConnectionToRoomReply& a, ClientConnectionToRoomReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientConnectionToRoomReply* New() const final {
    return CreateMaybeMessage<ClientConnectionToRoomReply>(NULL);
  }

  ClientConnectionToRoomReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientConnectionToRoomReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientConnectionToRoomReply& from);
  void MergeFrom(const ClientConnectionToRoomReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConnectionToRoomReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .serverMessageSystem.CreatedRoom room = 5;
  int room_size() const;
  void clear_room();
  static const int kRoomFieldNumber = 5;
  ::serverMessageSystem::CreatedRoom* mutable_room(int index);
  ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::CreatedRoom >*
      mutable_room();
  const ::serverMessageSystem::CreatedRoom& room(int index) const;
  ::serverMessageSystem::CreatedRoom* add_room();
  const ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::CreatedRoom >&
      room() const;

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool noRoomsAvailable = 3;
  void clear_noroomsavailable();
  static const int kNoRoomsAvailableFieldNumber = 3;
  bool noroomsavailable() const;
  void set_noroomsavailable(bool value);

  // uint32 freeSlotsLeft = 4;
  void clear_freeslotsleft();
  static const int kFreeSlotsLeftFieldNumber = 4;
  ::google::protobuf::uint32 freeslotsleft() const;
  void set_freeslotsleft(::google::protobuf::uint32 value);

  // uint32 queryOrder = 6;
  void clear_queryorder();
  static const int kQueryOrderFieldNumber = 6;
  ::google::protobuf::uint32 queryorder() const;
  void set_queryorder(::google::protobuf::uint32 value);

  // uint32 querySize = 7;
  void clear_querysize();
  static const int kQuerySizeFieldNumber = 7;
  ::google::protobuf::uint32 querysize() const;
  void set_querysize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ClientConnectionToRoomReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::CreatedRoom > room_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  bool noroomsavailable_;
  ::google::protobuf::uint32 freeslotsleft_;
  ::google::protobuf::uint32 queryorder_;
  ::google::protobuf::uint32 querysize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerQueryOrderNotification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerQueryOrderNotification) */ {
 public:
  ServerQueryOrderNotification();
  virtual ~ServerQueryOrderNotification();

  ServerQueryOrderNotification(const ServerQueryOrderNotification& from);

  inline ServerQueryOrderNotification& operator=(const ServerQueryOrderNotification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerQueryOrderNotification(ServerQueryOrderNotification&& from) noexcept
    : ServerQueryOrderNotification() {
    *this = ::std::move(from);
  }

  inline ServerQueryOrderNotification& operator=(ServerQueryOrderNotification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerQueryOrderNotification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerQueryOrderNotification* internal_default_instance() {
    return reinterpret_cast<const ServerQueryOrderNotification*>(
               &_ServerQueryOrderNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ServerQueryOrderNotification* other);
  friend void swap(ServerQueryOrderNotification& a, ServerQueryOrderNotification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerQueryOrderNotification* New() const final {
    return CreateMaybeMessage<ServerQueryOrderNotification>(NULL);
  }

  ServerQueryOrderNotification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerQueryOrderNotification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerQueryOrderNotification& from);
  void MergeFrom(const ServerQueryOrderNotification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerQueryOrderNotification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // uint32 queryOrder = 3;
  void clear_queryorder();
  static const int kQueryOrderFieldNumber = 3;
  ::google::protobuf::uint32 queryorder() const;
  void set_queryorder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerQueryOrderNotification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  ::google::protobuf::uint32 queryorder_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerReportsOpponentIsEnteringRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerReportsOpponentIsEnteringRoom) */ {
 public:
  ServerReportsOpponentIsEnteringRoom();
  virtual ~ServerReportsOpponentIsEnteringRoom();

  ServerReportsOpponentIsEnteringRoom(const ServerReportsOpponentIsEnteringRoom& from);

  inline ServerReportsOpponentIsEnteringRoom& operator=(const ServerReportsOpponentIsEnteringRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerReportsOpponentIsEnteringRoom(ServerReportsOpponentIsEnteringRoom&& from) noexcept
    : ServerReportsOpponentIsEnteringRoom() {
    *this = ::std::move(from);
  }

  inline ServerReportsOpponentIsEnteringRoom& operator=(ServerReportsOpponentIsEnteringRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerReportsOpponentIsEnteringRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerReportsOpponentIsEnteringRoom* internal_default_instance() {
    return reinterpret_cast<const ServerReportsOpponentIsEnteringRoom*>(
               &_ServerReportsOpponentIsEnteringRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ServerReportsOpponentIsEnteringRoom* other);
  friend void swap(ServerReportsOpponentIsEnteringRoom& a, ServerReportsOpponentIsEnteringRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerReportsOpponentIsEnteringRoom* New() const final {
    return CreateMaybeMessage<ServerReportsOpponentIsEnteringRoom>(NULL);
  }

  ServerReportsOpponentIsEnteringRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerReportsOpponentIsEnteringRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerReportsOpponentIsEnteringRoom& from);
  void MergeFrom(const ServerReportsOpponentIsEnteringRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerReportsOpponentIsEnteringRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string opponentName = 3;
  void clear_opponentname();
  static const int kOpponentNameFieldNumber = 3;
  const ::std::string& opponentname() const;
  void set_opponentname(const ::std::string& value);
  #if LANG_CXX11
  void set_opponentname(::std::string&& value);
  #endif
  void set_opponentname(const char* value);
  void set_opponentname(const char* value, size_t size);
  ::std::string* mutable_opponentname();
  ::std::string* release_opponentname();
  void set_allocated_opponentname(::std::string* opponentname);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // uint32 roomID = 4;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 4;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerReportsOpponentIsEnteringRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr opponentname_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  ::google::protobuf::uint32 roomid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChartMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ChartMessage) */ {
 public:
  ChartMessage();
  virtual ~ChartMessage();

  ChartMessage(const ChartMessage& from);

  inline ChartMessage& operator=(const ChartMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChartMessage(ChartMessage&& from) noexcept
    : ChartMessage() {
    *this = ::std::move(from);
  }

  inline ChartMessage& operator=(ChartMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChartMessage* internal_default_instance() {
    return reinterpret_cast<const ChartMessage*>(
               &_ChartMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ChartMessage* other);
  friend void swap(ChartMessage& a, ChartMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChartMessage* New() const final {
    return CreateMaybeMessage<ChartMessage>(NULL);
  }

  ChartMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChartMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChartMessage& from);
  void MergeFrom(const ChartMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string senderName = 3;
  void clear_sendername();
  static const int kSenderNameFieldNumber = 3;
  const ::std::string& sendername() const;
  void set_sendername(const ::std::string& value);
  #if LANG_CXX11
  void set_sendername(::std::string&& value);
  #endif
  void set_sendername(const char* value);
  void set_sendername(const char* value, size_t size);
  ::std::string* mutable_sendername();
  ::std::string* release_sendername();
  void set_allocated_sendername(::std::string* sendername);

  // string chartMessage = 4;
  void clear_chartmessage();
  static const int kChartMessageFieldNumber = 4;
  const ::std::string& chartmessage() const;
  void set_chartmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_chartmessage(::std::string&& value);
  #endif
  void set_chartmessage(const char* value);
  void set_chartmessage(const char* value, size_t size);
  ::std::string* mutable_chartmessage();
  ::std::string* release_chartmessage();
  void set_allocated_chartmessage(::std::string* chartmessage);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ChartSubSysCommandsID chartCmdID = 2;
  void clear_chartcmdid();
  static const int kChartCmdIDFieldNumber = 2;
  ::serverMessageSystem::ChartSubSysCommandsID chartcmdid() const;
  void set_chartcmdid(::serverMessageSystem::ChartSubSysCommandsID value);

  // uint32 roomID = 5;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 5;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ChartMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sendername_;
  ::google::protobuf::internal::ArenaStringPtr chartmessage_;
  ::serverMessageSystem::CommonHeader* header_;
  int chartcmdid_;
  ::google::protobuf::uint32 roomid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DefaultMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.DefaultMessage) */ {
 public:
  DefaultMessage();
  virtual ~DefaultMessage();

  DefaultMessage(const DefaultMessage& from);

  inline DefaultMessage& operator=(const DefaultMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DefaultMessage(DefaultMessage&& from) noexcept
    : DefaultMessage() {
    *this = ::std::move(from);
  }

  inline DefaultMessage& operator=(DefaultMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DefaultMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DefaultMessage* internal_default_instance() {
    return reinterpret_cast<const DefaultMessage*>(
               &_DefaultMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DefaultMessage* other);
  friend void swap(DefaultMessage& a, DefaultMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DefaultMessage* New() const final {
    return CreateMaybeMessage<DefaultMessage>(NULL);
  }

  DefaultMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DefaultMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DefaultMessage& from);
  void MergeFrom(const DefaultMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ChartSubSysCommandsID chartCmdID = 2;
  void clear_chartcmdid();
  static const int kChartCmdIDFieldNumber = 2;
  ::serverMessageSystem::ChartSubSysCommandsID chartcmdid() const;
  void set_chartcmdid(::serverMessageSystem::ChartSubSysCommandsID value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.DefaultMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::CommonHeader* header_;
  int chartcmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerRoomChangesInSelectableList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerRoomChangesInSelectableList) */ {
 public:
  ServerRoomChangesInSelectableList();
  virtual ~ServerRoomChangesInSelectableList();

  ServerRoomChangesInSelectableList(const ServerRoomChangesInSelectableList& from);

  inline ServerRoomChangesInSelectableList& operator=(const ServerRoomChangesInSelectableList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerRoomChangesInSelectableList(ServerRoomChangesInSelectableList&& from) noexcept
    : ServerRoomChangesInSelectableList() {
    *this = ::std::move(from);
  }

  inline ServerRoomChangesInSelectableList& operator=(ServerRoomChangesInSelectableList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerRoomChangesInSelectableList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerRoomChangesInSelectableList* internal_default_instance() {
    return reinterpret_cast<const ServerRoomChangesInSelectableList*>(
               &_ServerRoomChangesInSelectableList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ServerRoomChangesInSelectableList* other);
  friend void swap(ServerRoomChangesInSelectableList& a, ServerRoomChangesInSelectableList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerRoomChangesInSelectableList* New() const final {
    return CreateMaybeMessage<ServerRoomChangesInSelectableList>(NULL);
  }

  ServerRoomChangesInSelectableList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerRoomChangesInSelectableList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerRoomChangesInSelectableList& from);
  void MergeFrom(const ServerRoomChangesInSelectableList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerRoomChangesInSelectableList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.CreatedRoom room = 4;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 4;
  private:
  const ::serverMessageSystem::CreatedRoom& _internal_room() const;
  public:
  const ::serverMessageSystem::CreatedRoom& room() const;
  ::serverMessageSystem::CreatedRoom* release_room();
  ::serverMessageSystem::CreatedRoom* mutable_room();
  void set_allocated_room(::serverMessageSystem::CreatedRoom* room);

  // bool deletedOrUpdateFlag = 2;
  void clear_deletedorupdateflag();
  static const int kDeletedOrUpdateFlagFieldNumber = 2;
  bool deletedorupdateflag() const;
  void set_deletedorupdateflag(bool value);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 3;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 3;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerRoomChangesInSelectableList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::CommonHeader* header_;
  ::serverMessageSystem::CreatedRoom* room_;
  bool deletedorupdateflag_;
  int connectioncmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientWantedToEnterTheRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ClientWantedToEnterTheRoom) */ {
 public:
  ClientWantedToEnterTheRoom();
  virtual ~ClientWantedToEnterTheRoom();

  ClientWantedToEnterTheRoom(const ClientWantedToEnterTheRoom& from);

  inline ClientWantedToEnterTheRoom& operator=(const ClientWantedToEnterTheRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientWantedToEnterTheRoom(ClientWantedToEnterTheRoom&& from) noexcept
    : ClientWantedToEnterTheRoom() {
    *this = ::std::move(from);
  }

  inline ClientWantedToEnterTheRoom& operator=(ClientWantedToEnterTheRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientWantedToEnterTheRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientWantedToEnterTheRoom* internal_default_instance() {
    return reinterpret_cast<const ClientWantedToEnterTheRoom*>(
               &_ClientWantedToEnterTheRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ClientWantedToEnterTheRoom* other);
  friend void swap(ClientWantedToEnterTheRoom& a, ClientWantedToEnterTheRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientWantedToEnterTheRoom* New() const final {
    return CreateMaybeMessage<ClientWantedToEnterTheRoom>(NULL);
  }

  ClientWantedToEnterTheRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientWantedToEnterTheRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientWantedToEnterTheRoom& from);
  void MergeFrom(const ClientWantedToEnterTheRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientWantedToEnterTheRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 3;
  void clear_clientname();
  static const int kClientNameFieldNumber = 3;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // uint32 roomID = 4;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 4;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ClientWantedToEnterTheRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  ::google::protobuf::uint32 roomid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerClientWantedToEnterTheRoomReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerClientWantedToEnterTheRoomReply) */ {
 public:
  ServerClientWantedToEnterTheRoomReply();
  virtual ~ServerClientWantedToEnterTheRoomReply();

  ServerClientWantedToEnterTheRoomReply(const ServerClientWantedToEnterTheRoomReply& from);

  inline ServerClientWantedToEnterTheRoomReply& operator=(const ServerClientWantedToEnterTheRoomReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerClientWantedToEnterTheRoomReply(ServerClientWantedToEnterTheRoomReply&& from) noexcept
    : ServerClientWantedToEnterTheRoomReply() {
    *this = ::std::move(from);
  }

  inline ServerClientWantedToEnterTheRoomReply& operator=(ServerClientWantedToEnterTheRoomReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerClientWantedToEnterTheRoomReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerClientWantedToEnterTheRoomReply* internal_default_instance() {
    return reinterpret_cast<const ServerClientWantedToEnterTheRoomReply*>(
               &_ServerClientWantedToEnterTheRoomReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ServerClientWantedToEnterTheRoomReply* other);
  friend void swap(ServerClientWantedToEnterTheRoomReply& a, ServerClientWantedToEnterTheRoomReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerClientWantedToEnterTheRoomReply* New() const final {
    return CreateMaybeMessage<ServerClientWantedToEnterTheRoomReply>(NULL);
  }

  ServerClientWantedToEnterTheRoomReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerClientWantedToEnterTheRoomReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerClientWantedToEnterTheRoomReply& from);
  void MergeFrom(const ServerClientWantedToEnterTheRoomReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerClientWantedToEnterTheRoomReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string masterName = 4;
  void clear_mastername();
  static const int kMasterNameFieldNumber = 4;
  const ::std::string& mastername() const;
  void set_mastername(const ::std::string& value);
  #if LANG_CXX11
  void set_mastername(::std::string&& value);
  #endif
  void set_mastername(const char* value);
  void set_mastername(const char* value, size_t size);
  ::std::string* mutable_mastername();
  ::std::string* release_mastername();
  void set_allocated_mastername(::std::string* mastername);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.CreatedRoom room = 5;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 5;
  private:
  const ::serverMessageSystem::CreatedRoom& _internal_room() const;
  public:
  const ::serverMessageSystem::CreatedRoom& room() const;
  ::serverMessageSystem::CreatedRoom* release_room();
  ::serverMessageSystem::CreatedRoom* mutable_room();
  void set_allocated_room(::serverMessageSystem::CreatedRoom* room);

  // .serverMessageSystem.GameSettings settings = 6;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 6;
  private:
  const ::serverMessageSystem::GameSettings& _internal_settings() const;
  public:
  const ::serverMessageSystem::GameSettings& settings() const;
  ::serverMessageSystem::GameSettings* release_settings();
  ::serverMessageSystem::GameSettings* mutable_settings();
  void set_allocated_settings(::serverMessageSystem::GameSettings* settings);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool entranceAllowed = 3;
  void clear_entranceallowed();
  static const int kEntranceAllowedFieldNumber = 3;
  bool entranceallowed() const;
  void set_entranceallowed(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerClientWantedToEnterTheRoomReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mastername_;
  ::serverMessageSystem::CommonHeader* header_;
  ::serverMessageSystem::CreatedRoom* room_;
  ::serverMessageSystem::GameSettings* settings_;
  int connectioncmdid_;
  bool entranceallowed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerReportsClientIsLeaving : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerReportsClientIsLeaving) */ {
 public:
  ServerReportsClientIsLeaving();
  virtual ~ServerReportsClientIsLeaving();

  ServerReportsClientIsLeaving(const ServerReportsClientIsLeaving& from);

  inline ServerReportsClientIsLeaving& operator=(const ServerReportsClientIsLeaving& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerReportsClientIsLeaving(ServerReportsClientIsLeaving&& from) noexcept
    : ServerReportsClientIsLeaving() {
    *this = ::std::move(from);
  }

  inline ServerReportsClientIsLeaving& operator=(ServerReportsClientIsLeaving&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerReportsClientIsLeaving& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerReportsClientIsLeaving* internal_default_instance() {
    return reinterpret_cast<const ServerReportsClientIsLeaving*>(
               &_ServerReportsClientIsLeaving_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ServerReportsClientIsLeaving* other);
  friend void swap(ServerReportsClientIsLeaving& a, ServerReportsClientIsLeaving& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerReportsClientIsLeaving* New() const final {
    return CreateMaybeMessage<ServerReportsClientIsLeaving>(NULL);
  }

  ServerReportsClientIsLeaving* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerReportsClientIsLeaving>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerReportsClientIsLeaving& from);
  void MergeFrom(const ServerReportsClientIsLeaving& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerReportsClientIsLeaving* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 4;
  void clear_clientname();
  static const int kClientNameFieldNumber = 4;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::serverMessageSystem::CommonHeader& _internal_header() const;
  public:
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // uint32 socketDescriptor = 3;
  void clear_socketdescriptor();
  static const int kSocketDescriptorFieldNumber = 3;
  ::google::protobuf::uint32 socketdescriptor() const;
  void set_socketdescriptor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerReportsClientIsLeaving)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  ::google::protobuf::uint32 socketdescriptor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_serverMessageSystem_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonHeader

// .serverMessageSystem.SubSystemID subSystem = 1;
inline void CommonHeader::clear_subsystem() {
  subsystem_ = 0;
}
inline ::serverMessageSystem::SubSystemID CommonHeader::subsystem() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CommonHeader.subSystem)
  return static_cast< ::serverMessageSystem::SubSystemID >(subsystem_);
}
inline void CommonHeader::set_subsystem(::serverMessageSystem::SubSystemID value) {
  
  subsystem_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CommonHeader.subSystem)
}

// uint32 commandId = 2;
inline void CommonHeader::clear_commandid() {
  commandid_ = 0u;
}
inline ::google::protobuf::uint32 CommonHeader::commandid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CommonHeader.commandId)
  return commandid_;
}
inline void CommonHeader::set_commandid(::google::protobuf::uint32 value) {
  
  commandid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CommonHeader.commandId)
}

// -------------------------------------------------------------------

// TimeSettings

// uint32 totalTimeToMove = 1;
inline void TimeSettings::clear_totaltimetomove() {
  totaltimetomove_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::totaltimetomove() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.totalTimeToMove)
  return totaltimetomove_;
}
inline void TimeSettings::set_totaltimetomove(::google::protobuf::uint32 value) {
  
  totaltimetomove_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.totalTimeToMove)
}

// uint32 timeToThink = 2;
inline void TimeSettings::clear_timetothink() {
  timetothink_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::timetothink() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.timeToThink)
  return timetothink_;
}
inline void TimeSettings::set_timetothink(::google::protobuf::uint32 value) {
  
  timetothink_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.timeToThink)
}

// uint32 timeForOpponentsDecision = 3;
inline void TimeSettings::clear_timeforopponentsdecision() {
  timeforopponentsdecision_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::timeforopponentsdecision() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.timeForOpponentsDecision)
  return timeforopponentsdecision_;
}
inline void TimeSettings::set_timeforopponentsdecision(::google::protobuf::uint32 value) {
  
  timeforopponentsdecision_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.timeForOpponentsDecision)
}

// uint32 diplomacyTime = 4;
inline void TimeSettings::clear_diplomacytime() {
  diplomacytime_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::diplomacytime() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.diplomacyTime)
  return diplomacytime_;
}
inline void TimeSettings::set_diplomacytime(::google::protobuf::uint32 value) {
  
  diplomacytime_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.diplomacyTime)
}

// -------------------------------------------------------------------

// GameType

// bool hasAddonWildAxe = 1;
inline void GameType::clear_hasaddonwildaxe() {
  hasaddonwildaxe_ = false;
}
inline bool GameType::hasaddonwildaxe() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.hasAddonWildAxe)
  return hasaddonwildaxe_;
}
inline void GameType::set_hasaddonwildaxe(bool value) {
  
  hasaddonwildaxe_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.hasAddonWildAxe)
}

// bool hasAddonClericalErrors = 2;
inline void GameType::clear_hasaddonclericalerrors() {
  hasaddonclericalerrors_ = false;
}
inline bool GameType::hasaddonclericalerrors() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.hasAddonClericalErrors)
  return hasaddonclericalerrors_;
}
inline void GameType::set_hasaddonclericalerrors(bool value) {
  
  hasaddonclericalerrors_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.hasAddonClericalErrors)
}

// .serverMessageSystem.RulesType rulesType = 3;
inline void GameType::clear_rulestype() {
  rulestype_ = 0;
}
inline ::serverMessageSystem::RulesType GameType::rulestype() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.rulesType)
  return static_cast< ::serverMessageSystem::RulesType >(rulestype_);
}
inline void GameType::set_rulestype(::serverMessageSystem::RulesType value) {
  
  rulestype_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.rulesType)
}

// -------------------------------------------------------------------

// GameSettings

// .serverMessageSystem.GameType gameType = 1;
inline bool GameSettings::has_gametype() const {
  return this != internal_default_instance() && gametype_ != NULL;
}
inline void GameSettings::clear_gametype() {
  if (GetArenaNoVirtual() == NULL && gametype_ != NULL) {
    delete gametype_;
  }
  gametype_ = NULL;
}
inline const ::serverMessageSystem::GameType& GameSettings::_internal_gametype() const {
  return *gametype_;
}
inline const ::serverMessageSystem::GameType& GameSettings::gametype() const {
  const ::serverMessageSystem::GameType* p = gametype_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.gameType)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::GameType*>(
      &::serverMessageSystem::_GameType_default_instance_);
}
inline ::serverMessageSystem::GameType* GameSettings::release_gametype() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.GameSettings.gameType)
  
  ::serverMessageSystem::GameType* temp = gametype_;
  gametype_ = NULL;
  return temp;
}
inline ::serverMessageSystem::GameType* GameSettings::mutable_gametype() {
  
  if (gametype_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::GameType>(GetArenaNoVirtual());
    gametype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.GameSettings.gameType)
  return gametype_;
}
inline void GameSettings::set_allocated_gametype(::serverMessageSystem::GameType* gametype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gametype_;
  }
  if (gametype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gametype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gametype, submessage_arena);
    }
    
  } else {
    
  }
  gametype_ = gametype;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.GameSettings.gameType)
}

// .serverMessageSystem.TimeSettings timeSettings = 2;
inline bool GameSettings::has_timesettings() const {
  return this != internal_default_instance() && timesettings_ != NULL;
}
inline void GameSettings::clear_timesettings() {
  if (GetArenaNoVirtual() == NULL && timesettings_ != NULL) {
    delete timesettings_;
  }
  timesettings_ = NULL;
}
inline const ::serverMessageSystem::TimeSettings& GameSettings::_internal_timesettings() const {
  return *timesettings_;
}
inline const ::serverMessageSystem::TimeSettings& GameSettings::timesettings() const {
  const ::serverMessageSystem::TimeSettings* p = timesettings_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.timeSettings)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::TimeSettings*>(
      &::serverMessageSystem::_TimeSettings_default_instance_);
}
inline ::serverMessageSystem::TimeSettings* GameSettings::release_timesettings() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.GameSettings.timeSettings)
  
  ::serverMessageSystem::TimeSettings* temp = timesettings_;
  timesettings_ = NULL;
  return temp;
}
inline ::serverMessageSystem::TimeSettings* GameSettings::mutable_timesettings() {
  
  if (timesettings_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::TimeSettings>(GetArenaNoVirtual());
    timesettings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.GameSettings.timeSettings)
  return timesettings_;
}
inline void GameSettings::set_allocated_timesettings(::serverMessageSystem::TimeSettings* timesettings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timesettings_;
  }
  if (timesettings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timesettings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timesettings, submessage_arena);
    }
    
  } else {
    
  }
  timesettings_ = timesettings;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.GameSettings.timeSettings)
}

// uint32 maximumNumberOfPlayers = 3;
inline void GameSettings::clear_maximumnumberofplayers() {
  maximumnumberofplayers_ = 0u;
}
inline ::google::protobuf::uint32 GameSettings::maximumnumberofplayers() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.maximumNumberOfPlayers)
  return maximumnumberofplayers_;
}
inline void GameSettings::set_maximumnumberofplayers(::google::protobuf::uint32 value) {
  
  maximumnumberofplayers_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameSettings.maximumNumberOfPlayers)
}

// bool settingsCorrectionAllowed = 4;
inline void GameSettings::clear_settingscorrectionallowed() {
  settingscorrectionallowed_ = false;
}
inline bool GameSettings::settingscorrectionallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.settingsCorrectionAllowed)
  return settingscorrectionallowed_;
}
inline void GameSettings::set_settingscorrectionallowed(bool value) {
  
  settingscorrectionallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameSettings.settingsCorrectionAllowed)
}

// -------------------------------------------------------------------

// RoomCreationErrors

// bool noFreeSlotsAvailable = 1;
inline void RoomCreationErrors::clear_nofreeslotsavailable() {
  nofreeslotsavailable_ = false;
}
inline bool RoomCreationErrors::nofreeslotsavailable() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.noFreeSlotsAvailable)
  return nofreeslotsavailable_;
}
inline void RoomCreationErrors::set_nofreeslotsavailable(bool value) {
  
  nofreeslotsavailable_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.noFreeSlotsAvailable)
}

// bool rulesAreNotSupported = 2;
inline void RoomCreationErrors::clear_rulesarenotsupported() {
  rulesarenotsupported_ = false;
}
inline bool RoomCreationErrors::rulesarenotsupported() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.rulesAreNotSupported)
  return rulesarenotsupported_;
}
inline void RoomCreationErrors::set_rulesarenotsupported(bool value) {
  
  rulesarenotsupported_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.rulesAreNotSupported)
}

// bool incorrectSettings = 3;
inline void RoomCreationErrors::clear_incorrectsettings() {
  incorrectsettings_ = false;
}
inline bool RoomCreationErrors::incorrectsettings() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.incorrectSettings)
  return incorrectsettings_;
}
inline void RoomCreationErrors::set_incorrectsettings(bool value) {
  
  incorrectsettings_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.incorrectSettings)
}

// -------------------------------------------------------------------

// Player

// string playerName = 1;
inline void Player::clear_playername() {
  playername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::playername() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.Player.playerName)
  return playername_.GetNoArena();
}
inline void Player::set_playername(const ::std::string& value) {
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.Player.playerName)
}
#if LANG_CXX11
inline void Player::set_playername(::std::string&& value) {
  
  playername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.Player.playerName)
}
#endif
inline void Player::set_playername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.Player.playerName)
}
inline void Player::set_playername(const char* value, size_t size) {
  
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.Player.playerName)
}
inline ::std::string* Player::mutable_playername() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.Player.playerName)
  return playername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_playername() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.Player.playerName)
  
  return playername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_playername(::std::string* playername) {
  if (playername != NULL) {
    
  } else {
    
  }
  playername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playername);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.Player.playerName)
}

// uint32 playerID = 2;
inline void Player::clear_playerid() {
  playerid_ = 0u;
}
inline ::google::protobuf::uint32 Player::playerid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.Player.playerID)
  return playerid_;
}
inline void Player::set_playerid(::google::protobuf::uint32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.Player.playerID)
}

// -------------------------------------------------------------------

// CreatedRoom

// uint32 roomID = 1;
inline void CreatedRoom::clear_roomid() {
  roomid_ = 0u;
}
inline ::google::protobuf::uint32 CreatedRoom::roomid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CreatedRoom.roomID)
  return roomid_;
}
inline void CreatedRoom::set_roomid(::google::protobuf::uint32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CreatedRoom.roomID)
}

// string roomName = 2;
inline void CreatedRoom::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatedRoom::roomname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CreatedRoom.roomName)
  return roomname_.GetNoArena();
}
inline void CreatedRoom::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.CreatedRoom.roomName)
}
#if LANG_CXX11
inline void CreatedRoom::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.CreatedRoom.roomName)
}
#endif
inline void CreatedRoom::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.CreatedRoom.roomName)
}
inline void CreatedRoom::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.CreatedRoom.roomName)
}
inline ::std::string* CreatedRoom::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.CreatedRoom.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatedRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.CreatedRoom.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatedRoom::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.CreatedRoom.roomName)
}

// uint32 players = 3;
inline void CreatedRoom::clear_players() {
  players_ = 0u;
}
inline ::google::protobuf::uint32 CreatedRoom::players() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CreatedRoom.players)
  return players_;
}
inline void CreatedRoom::set_players(::google::protobuf::uint32 value) {
  
  players_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CreatedRoom.players)
}

// uint32 maximumNumberOfPlayers = 4;
inline void CreatedRoom::clear_maximumnumberofplayers() {
  maximumnumberofplayers_ = 0u;
}
inline ::google::protobuf::uint32 CreatedRoom::maximumnumberofplayers() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CreatedRoom.maximumNumberOfPlayers)
  return maximumnumberofplayers_;
}
inline void CreatedRoom::set_maximumnumberofplayers(::google::protobuf::uint32 value) {
  
  maximumnumberofplayers_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CreatedRoom.maximumNumberOfPlayers)
}

// repeated .serverMessageSystem.Player player = 5;
inline int CreatedRoom::player_size() const {
  return player_.size();
}
inline void CreatedRoom::clear_player() {
  player_.Clear();
}
inline ::serverMessageSystem::Player* CreatedRoom::mutable_player(int index) {
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.CreatedRoom.player)
  return player_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::Player >*
CreatedRoom::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:serverMessageSystem.CreatedRoom.player)
  return &player_;
}
inline const ::serverMessageSystem::Player& CreatedRoom::player(int index) const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CreatedRoom.player)
  return player_.Get(index);
}
inline ::serverMessageSystem::Player* CreatedRoom::add_player() {
  // @@protoc_insertion_point(field_add:serverMessageSystem.CreatedRoom.player)
  return player_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::Player >&
CreatedRoom::player() const {
  // @@protoc_insertion_point(field_list:serverMessageSystem.CreatedRoom.player)
  return player_;
}

// -------------------------------------------------------------------

// ServerInputQuery

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerInputQuery::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerInputQuery::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerInputQuery::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerInputQuery::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerInputQuery::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerInputQuery::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.header)
  return header_;
}
inline void ServerInputQuery::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerInputQuery::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerInputQuery::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerInputQuery::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.connectionCmdID)
}

// string clientName = 3;
inline void ServerInputQuery::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInputQuery::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.clientName)
  return clientname_.GetNoArena();
}
inline void ServerInputQuery::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.clientName)
}
#if LANG_CXX11
inline void ServerInputQuery::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerInputQuery.clientName)
}
#endif
inline void ServerInputQuery::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerInputQuery.clientName)
}
inline void ServerInputQuery::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerInputQuery.clientName)
}
inline ::std::string* ServerInputQuery::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInputQuery::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInputQuery::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.clientName)
}

// string OsType = 4;
inline void ServerInputQuery::clear_ostype() {
  ostype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInputQuery::ostype() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.OsType)
  return ostype_.GetNoArena();
}
inline void ServerInputQuery::set_ostype(const ::std::string& value) {
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.OsType)
}
#if LANG_CXX11
inline void ServerInputQuery::set_ostype(::std::string&& value) {
  
  ostype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerInputQuery.OsType)
}
#endif
inline void ServerInputQuery::set_ostype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerInputQuery.OsType)
}
inline void ServerInputQuery::set_ostype(const char* value, size_t size) {
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerInputQuery.OsType)
}
inline ::std::string* ServerInputQuery::mutable_ostype() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.OsType)
  return ostype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInputQuery::release_ostype() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.OsType)
  
  return ostype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInputQuery::set_allocated_ostype(::std::string* ostype) {
  if (ostype != NULL) {
    
  } else {
    
  }
  ostype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ostype);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.OsType)
}

// -------------------------------------------------------------------

// ServerQueryReply

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerQueryReply::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerQueryReply::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerQueryReply::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerQueryReply::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerQueryReply::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerQueryReply.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerQueryReply::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerQueryReply.header)
  return header_;
}
inline void ServerQueryReply::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerQueryReply.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerQueryReply::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerQueryReply::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerQueryReply::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.connectionCmdID)
}

// bool roomCreationAllowed = 3;
inline void ServerQueryReply::clear_roomcreationallowed() {
  roomcreationallowed_ = false;
}
inline bool ServerQueryReply::roomcreationallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.roomCreationAllowed)
  return roomcreationallowed_;
}
inline void ServerQueryReply::set_roomcreationallowed(bool value) {
  
  roomcreationallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.roomCreationAllowed)
}

// bool connectionToRoomAllowed = 4;
inline void ServerQueryReply::clear_connectiontoroomallowed() {
  connectiontoroomallowed_ = false;
}
inline bool ServerQueryReply::connectiontoroomallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.connectionToRoomAllowed)
  return connectiontoroomallowed_;
}
inline void ServerQueryReply::set_connectiontoroomallowed(bool value) {
  
  connectiontoroomallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.connectionToRoomAllowed)
}

// string serverName = 5;
inline void ServerQueryReply::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerQueryReply::servername() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.serverName)
  return servername_.GetNoArena();
}
inline void ServerQueryReply::set_servername(const ::std::string& value) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.serverName)
}
#if LANG_CXX11
inline void ServerQueryReply::set_servername(::std::string&& value) {
  
  servername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerQueryReply.serverName)
}
#endif
inline void ServerQueryReply::set_servername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerQueryReply.serverName)
}
inline void ServerQueryReply::set_servername(const char* value, size_t size) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerQueryReply.serverName)
}
inline ::std::string* ServerQueryReply::mutable_servername() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerQueryReply.serverName)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerQueryReply::release_servername() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerQueryReply.serverName)
  
  return servername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerQueryReply::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    
  } else {
    
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerQueryReply.serverName)
}

// -------------------------------------------------------------------

// ClientRoomCreationRequest

// .serverMessageSystem.CommonHeader header = 1;
inline bool ClientRoomCreationRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClientRoomCreationRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ClientRoomCreationRequest::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ClientRoomCreationRequest::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ClientRoomCreationRequest::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationRequest.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ClientRoomCreationRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationRequest.header)
  return header_;
}
inline void ClientRoomCreationRequest::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationRequest.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ClientRoomCreationRequest::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ClientRoomCreationRequest::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationRequest.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ClientRoomCreationRequest::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationRequest.connectionCmdID)
}

// string clientName = 3;
inline void ClientRoomCreationRequest::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientRoomCreationRequest::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationRequest.clientName)
  return clientname_.GetNoArena();
}
inline void ClientRoomCreationRequest::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationRequest.clientName)
}
#if LANG_CXX11
inline void ClientRoomCreationRequest::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ClientRoomCreationRequest.clientName)
}
#endif
inline void ClientRoomCreationRequest::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ClientRoomCreationRequest.clientName)
}
inline void ClientRoomCreationRequest::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ClientRoomCreationRequest.clientName)
}
inline ::std::string* ClientRoomCreationRequest::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationRequest.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientRoomCreationRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationRequest.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientRoomCreationRequest::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationRequest.clientName)
}

// string roomName = 4;
inline void ClientRoomCreationRequest::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientRoomCreationRequest::roomname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationRequest.roomName)
  return roomname_.GetNoArena();
}
inline void ClientRoomCreationRequest::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationRequest.roomName)
}
#if LANG_CXX11
inline void ClientRoomCreationRequest::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ClientRoomCreationRequest.roomName)
}
#endif
inline void ClientRoomCreationRequest::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ClientRoomCreationRequest.roomName)
}
inline void ClientRoomCreationRequest::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ClientRoomCreationRequest.roomName)
}
inline ::std::string* ClientRoomCreationRequest::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationRequest.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientRoomCreationRequest::release_roomname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationRequest.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientRoomCreationRequest::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationRequest.roomName)
}

// .serverMessageSystem.GameSettings gameSettings = 5;
inline bool ClientRoomCreationRequest::has_gamesettings() const {
  return this != internal_default_instance() && gamesettings_ != NULL;
}
inline void ClientRoomCreationRequest::clear_gamesettings() {
  if (GetArenaNoVirtual() == NULL && gamesettings_ != NULL) {
    delete gamesettings_;
  }
  gamesettings_ = NULL;
}
inline const ::serverMessageSystem::GameSettings& ClientRoomCreationRequest::_internal_gamesettings() const {
  return *gamesettings_;
}
inline const ::serverMessageSystem::GameSettings& ClientRoomCreationRequest::gamesettings() const {
  const ::serverMessageSystem::GameSettings* p = gamesettings_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationRequest.gameSettings)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::GameSettings*>(
      &::serverMessageSystem::_GameSettings_default_instance_);
}
inline ::serverMessageSystem::GameSettings* ClientRoomCreationRequest::release_gamesettings() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationRequest.gameSettings)
  
  ::serverMessageSystem::GameSettings* temp = gamesettings_;
  gamesettings_ = NULL;
  return temp;
}
inline ::serverMessageSystem::GameSettings* ClientRoomCreationRequest::mutable_gamesettings() {
  
  if (gamesettings_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::GameSettings>(GetArenaNoVirtual());
    gamesettings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationRequest.gameSettings)
  return gamesettings_;
}
inline void ClientRoomCreationRequest::set_allocated_gamesettings(::serverMessageSystem::GameSettings* gamesettings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gamesettings_;
  }
  if (gamesettings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gamesettings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamesettings, submessage_arena);
    }
    
  } else {
    
  }
  gamesettings_ = gamesettings;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationRequest.gameSettings)
}

// -------------------------------------------------------------------

// ClientRoomCreationReply

// .serverMessageSystem.CommonHeader header = 1;
inline bool ClientRoomCreationReply::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClientRoomCreationReply::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ClientRoomCreationReply::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ClientRoomCreationReply::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ClientRoomCreationReply::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationReply.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ClientRoomCreationReply::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationReply.header)
  return header_;
}
inline void ClientRoomCreationReply::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationReply.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ClientRoomCreationReply::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ClientRoomCreationReply::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ClientRoomCreationReply::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationReply.connectionCmdID)
}

// bool connectionAllowed = 3;
inline void ClientRoomCreationReply::clear_connectionallowed() {
  connectionallowed_ = false;
}
inline bool ClientRoomCreationReply::connectionallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.connectionAllowed)
  return connectionallowed_;
}
inline void ClientRoomCreationReply::set_connectionallowed(bool value) {
  
  connectionallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationReply.connectionAllowed)
}

// uint32 slotID = 4;
inline void ClientRoomCreationReply::clear_slotid() {
  slotid_ = 0u;
}
inline ::google::protobuf::uint32 ClientRoomCreationReply::slotid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.slotID)
  return slotid_;
}
inline void ClientRoomCreationReply::set_slotid(::google::protobuf::uint32 value) {
  
  slotid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationReply.slotID)
}

// uint32 freeSlotsLeft = 5;
inline void ClientRoomCreationReply::clear_freeslotsleft() {
  freeslotsleft_ = 0u;
}
inline ::google::protobuf::uint32 ClientRoomCreationReply::freeslotsleft() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.freeSlotsLeft)
  return freeslotsleft_;
}
inline void ClientRoomCreationReply::set_freeslotsleft(::google::protobuf::uint32 value) {
  
  freeslotsleft_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientRoomCreationReply.freeSlotsLeft)
}

// .serverMessageSystem.RoomCreationErrors roomCreationErrors = 6;
inline bool ClientRoomCreationReply::has_roomcreationerrors() const {
  return this != internal_default_instance() && roomcreationerrors_ != NULL;
}
inline void ClientRoomCreationReply::clear_roomcreationerrors() {
  if (GetArenaNoVirtual() == NULL && roomcreationerrors_ != NULL) {
    delete roomcreationerrors_;
  }
  roomcreationerrors_ = NULL;
}
inline const ::serverMessageSystem::RoomCreationErrors& ClientRoomCreationReply::_internal_roomcreationerrors() const {
  return *roomcreationerrors_;
}
inline const ::serverMessageSystem::RoomCreationErrors& ClientRoomCreationReply::roomcreationerrors() const {
  const ::serverMessageSystem::RoomCreationErrors* p = roomcreationerrors_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientRoomCreationReply.roomCreationErrors)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::RoomCreationErrors*>(
      &::serverMessageSystem::_RoomCreationErrors_default_instance_);
}
inline ::serverMessageSystem::RoomCreationErrors* ClientRoomCreationReply::release_roomcreationerrors() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientRoomCreationReply.roomCreationErrors)
  
  ::serverMessageSystem::RoomCreationErrors* temp = roomcreationerrors_;
  roomcreationerrors_ = NULL;
  return temp;
}
inline ::serverMessageSystem::RoomCreationErrors* ClientRoomCreationReply::mutable_roomcreationerrors() {
  
  if (roomcreationerrors_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::RoomCreationErrors>(GetArenaNoVirtual());
    roomcreationerrors_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientRoomCreationReply.roomCreationErrors)
  return roomcreationerrors_;
}
inline void ClientRoomCreationReply::set_allocated_roomcreationerrors(::serverMessageSystem::RoomCreationErrors* roomcreationerrors) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roomcreationerrors_;
  }
  if (roomcreationerrors) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roomcreationerrors = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roomcreationerrors, submessage_arena);
    }
    
  } else {
    
  }
  roomcreationerrors_ = roomcreationerrors;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientRoomCreationReply.roomCreationErrors)
}

// -------------------------------------------------------------------

// ClientConnectionToRoomRequest

// .serverMessageSystem.CommonHeader header = 1;
inline bool ClientConnectionToRoomRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClientConnectionToRoomRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ClientConnectionToRoomRequest::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ClientConnectionToRoomRequest::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ClientConnectionToRoomRequest::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientConnectionToRoomRequest.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ClientConnectionToRoomRequest::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientConnectionToRoomRequest.header)
  return header_;
}
inline void ClientConnectionToRoomRequest::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientConnectionToRoomRequest.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ClientConnectionToRoomRequest::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ClientConnectionToRoomRequest::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomRequest.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ClientConnectionToRoomRequest::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomRequest.connectionCmdID)
}

// string clientName = 3;
inline void ClientConnectionToRoomRequest::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientConnectionToRoomRequest::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
  return clientname_.GetNoArena();
}
inline void ClientConnectionToRoomRequest::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
}
#if LANG_CXX11
inline void ClientConnectionToRoomRequest::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
}
#endif
inline void ClientConnectionToRoomRequest::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
}
inline void ClientConnectionToRoomRequest::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
}
inline ::std::string* ClientConnectionToRoomRequest::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConnectionToRoomRequest::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConnectionToRoomRequest::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientConnectionToRoomRequest.clientName)
}

// bool connectToAnyRoom = 4;
inline void ClientConnectionToRoomRequest::clear_connecttoanyroom() {
  connecttoanyroom_ = false;
}
inline bool ClientConnectionToRoomRequest::connecttoanyroom() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomRequest.connectToAnyRoom)
  return connecttoanyroom_;
}
inline void ClientConnectionToRoomRequest::set_connecttoanyroom(bool value) {
  
  connecttoanyroom_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomRequest.connectToAnyRoom)
}

// bool agreeToWait = 5;
inline void ClientConnectionToRoomRequest::clear_agreetowait() {
  agreetowait_ = false;
}
inline bool ClientConnectionToRoomRequest::agreetowait() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomRequest.agreeToWait)
  return agreetowait_;
}
inline void ClientConnectionToRoomRequest::set_agreetowait(bool value) {
  
  agreetowait_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomRequest.agreeToWait)
}

// -------------------------------------------------------------------

// ClientConnectionToRoomReply

// .serverMessageSystem.CommonHeader header = 1;
inline bool ClientConnectionToRoomReply::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClientConnectionToRoomReply::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ClientConnectionToRoomReply::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ClientConnectionToRoomReply::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ClientConnectionToRoomReply::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientConnectionToRoomReply.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ClientConnectionToRoomReply::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientConnectionToRoomReply.header)
  return header_;
}
inline void ClientConnectionToRoomReply::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientConnectionToRoomReply.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ClientConnectionToRoomReply::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ClientConnectionToRoomReply::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ClientConnectionToRoomReply::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomReply.connectionCmdID)
}

// bool noRoomsAvailable = 3;
inline void ClientConnectionToRoomReply::clear_noroomsavailable() {
  noroomsavailable_ = false;
}
inline bool ClientConnectionToRoomReply::noroomsavailable() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.noRoomsAvailable)
  return noroomsavailable_;
}
inline void ClientConnectionToRoomReply::set_noroomsavailable(bool value) {
  
  noroomsavailable_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomReply.noRoomsAvailable)
}

// uint32 freeSlotsLeft = 4;
inline void ClientConnectionToRoomReply::clear_freeslotsleft() {
  freeslotsleft_ = 0u;
}
inline ::google::protobuf::uint32 ClientConnectionToRoomReply::freeslotsleft() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.freeSlotsLeft)
  return freeslotsleft_;
}
inline void ClientConnectionToRoomReply::set_freeslotsleft(::google::protobuf::uint32 value) {
  
  freeslotsleft_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomReply.freeSlotsLeft)
}

// repeated .serverMessageSystem.CreatedRoom room = 5;
inline int ClientConnectionToRoomReply::room_size() const {
  return room_.size();
}
inline void ClientConnectionToRoomReply::clear_room() {
  room_.Clear();
}
inline ::serverMessageSystem::CreatedRoom* ClientConnectionToRoomReply::mutable_room(int index) {
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientConnectionToRoomReply.room)
  return room_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::CreatedRoom >*
ClientConnectionToRoomReply::mutable_room() {
  // @@protoc_insertion_point(field_mutable_list:serverMessageSystem.ClientConnectionToRoomReply.room)
  return &room_;
}
inline const ::serverMessageSystem::CreatedRoom& ClientConnectionToRoomReply::room(int index) const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.room)
  return room_.Get(index);
}
inline ::serverMessageSystem::CreatedRoom* ClientConnectionToRoomReply::add_room() {
  // @@protoc_insertion_point(field_add:serverMessageSystem.ClientConnectionToRoomReply.room)
  return room_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::serverMessageSystem::CreatedRoom >&
ClientConnectionToRoomReply::room() const {
  // @@protoc_insertion_point(field_list:serverMessageSystem.ClientConnectionToRoomReply.room)
  return room_;
}

// uint32 queryOrder = 6;
inline void ClientConnectionToRoomReply::clear_queryorder() {
  queryorder_ = 0u;
}
inline ::google::protobuf::uint32 ClientConnectionToRoomReply::queryorder() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.queryOrder)
  return queryorder_;
}
inline void ClientConnectionToRoomReply::set_queryorder(::google::protobuf::uint32 value) {
  
  queryorder_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomReply.queryOrder)
}

// uint32 querySize = 7;
inline void ClientConnectionToRoomReply::clear_querysize() {
  querysize_ = 0u;
}
inline ::google::protobuf::uint32 ClientConnectionToRoomReply::querysize() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientConnectionToRoomReply.querySize)
  return querysize_;
}
inline void ClientConnectionToRoomReply::set_querysize(::google::protobuf::uint32 value) {
  
  querysize_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientConnectionToRoomReply.querySize)
}

// -------------------------------------------------------------------

// ServerQueryOrderNotification

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerQueryOrderNotification::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerQueryOrderNotification::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerQueryOrderNotification::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerQueryOrderNotification::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryOrderNotification.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerQueryOrderNotification::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerQueryOrderNotification.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerQueryOrderNotification::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerQueryOrderNotification.header)
  return header_;
}
inline void ServerQueryOrderNotification::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerQueryOrderNotification.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerQueryOrderNotification::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerQueryOrderNotification::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryOrderNotification.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerQueryOrderNotification::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryOrderNotification.connectionCmdID)
}

// uint32 queryOrder = 3;
inline void ServerQueryOrderNotification::clear_queryorder() {
  queryorder_ = 0u;
}
inline ::google::protobuf::uint32 ServerQueryOrderNotification::queryorder() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryOrderNotification.queryOrder)
  return queryorder_;
}
inline void ServerQueryOrderNotification::set_queryorder(::google::protobuf::uint32 value) {
  
  queryorder_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryOrderNotification.queryOrder)
}

// -------------------------------------------------------------------

// ServerReportsOpponentIsEnteringRoom

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerReportsOpponentIsEnteringRoom::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerReportsOpponentIsEnteringRoom::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerReportsOpponentIsEnteringRoom::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerReportsOpponentIsEnteringRoom::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerReportsOpponentIsEnteringRoom::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerReportsOpponentIsEnteringRoom::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.header)
  return header_;
}
inline void ServerReportsOpponentIsEnteringRoom::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerReportsOpponentIsEnteringRoom::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerReportsOpponentIsEnteringRoom::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerReportsOpponentIsEnteringRoom::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.connectionCmdID)
}

// string opponentName = 3;
inline void ServerReportsOpponentIsEnteringRoom::clear_opponentname() {
  opponentname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerReportsOpponentIsEnteringRoom::opponentname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
  return opponentname_.GetNoArena();
}
inline void ServerReportsOpponentIsEnteringRoom::set_opponentname(const ::std::string& value) {
  
  opponentname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
}
#if LANG_CXX11
inline void ServerReportsOpponentIsEnteringRoom::set_opponentname(::std::string&& value) {
  
  opponentname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
}
#endif
inline void ServerReportsOpponentIsEnteringRoom::set_opponentname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  opponentname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
}
inline void ServerReportsOpponentIsEnteringRoom::set_opponentname(const char* value, size_t size) {
  
  opponentname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
}
inline ::std::string* ServerReportsOpponentIsEnteringRoom::mutable_opponentname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
  return opponentname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerReportsOpponentIsEnteringRoom::release_opponentname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
  
  return opponentname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerReportsOpponentIsEnteringRoom::set_allocated_opponentname(::std::string* opponentname) {
  if (opponentname != NULL) {
    
  } else {
    
  }
  opponentname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opponentname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.opponentName)
}

// uint32 roomID = 4;
inline void ServerReportsOpponentIsEnteringRoom::clear_roomid() {
  roomid_ = 0u;
}
inline ::google::protobuf::uint32 ServerReportsOpponentIsEnteringRoom::roomid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.roomID)
  return roomid_;
}
inline void ServerReportsOpponentIsEnteringRoom::set_roomid(::google::protobuf::uint32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsOpponentIsEnteringRoom.roomID)
}

// -------------------------------------------------------------------

// ChartMessage

// .serverMessageSystem.CommonHeader header = 1;
inline bool ChartMessage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ChartMessage::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ChartMessage::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ChartMessage::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ChartMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ChartMessage::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ChartMessage.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ChartMessage::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ChartMessage.header)
  return header_;
}
inline void ChartMessage::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ChartMessage.header)
}

// .serverMessageSystem.ChartSubSysCommandsID chartCmdID = 2;
inline void ChartMessage::clear_chartcmdid() {
  chartcmdid_ = 0;
}
inline ::serverMessageSystem::ChartSubSysCommandsID ChartMessage::chartcmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ChartMessage.chartCmdID)
  return static_cast< ::serverMessageSystem::ChartSubSysCommandsID >(chartcmdid_);
}
inline void ChartMessage::set_chartcmdid(::serverMessageSystem::ChartSubSysCommandsID value) {
  
  chartcmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ChartMessage.chartCmdID)
}

// string senderName = 3;
inline void ChartMessage::clear_sendername() {
  sendername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChartMessage::sendername() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ChartMessage.senderName)
  return sendername_.GetNoArena();
}
inline void ChartMessage::set_sendername(const ::std::string& value) {
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ChartMessage.senderName)
}
#if LANG_CXX11
inline void ChartMessage::set_sendername(::std::string&& value) {
  
  sendername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ChartMessage.senderName)
}
#endif
inline void ChartMessage::set_sendername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ChartMessage.senderName)
}
inline void ChartMessage::set_sendername(const char* value, size_t size) {
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ChartMessage.senderName)
}
inline ::std::string* ChartMessage::mutable_sendername() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ChartMessage.senderName)
  return sendername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChartMessage::release_sendername() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ChartMessage.senderName)
  
  return sendername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChartMessage::set_allocated_sendername(::std::string* sendername) {
  if (sendername != NULL) {
    
  } else {
    
  }
  sendername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sendername);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ChartMessage.senderName)
}

// string chartMessage = 4;
inline void ChartMessage::clear_chartmessage() {
  chartmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChartMessage::chartmessage() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ChartMessage.chartMessage)
  return chartmessage_.GetNoArena();
}
inline void ChartMessage::set_chartmessage(const ::std::string& value) {
  
  chartmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ChartMessage.chartMessage)
}
#if LANG_CXX11
inline void ChartMessage::set_chartmessage(::std::string&& value) {
  
  chartmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ChartMessage.chartMessage)
}
#endif
inline void ChartMessage::set_chartmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chartmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ChartMessage.chartMessage)
}
inline void ChartMessage::set_chartmessage(const char* value, size_t size) {
  
  chartmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ChartMessage.chartMessage)
}
inline ::std::string* ChartMessage::mutable_chartmessage() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ChartMessage.chartMessage)
  return chartmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChartMessage::release_chartmessage() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ChartMessage.chartMessage)
  
  return chartmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChartMessage::set_allocated_chartmessage(::std::string* chartmessage) {
  if (chartmessage != NULL) {
    
  } else {
    
  }
  chartmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chartmessage);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ChartMessage.chartMessage)
}

// uint32 roomID = 5;
inline void ChartMessage::clear_roomid() {
  roomid_ = 0u;
}
inline ::google::protobuf::uint32 ChartMessage::roomid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ChartMessage.roomID)
  return roomid_;
}
inline void ChartMessage::set_roomid(::google::protobuf::uint32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ChartMessage.roomID)
}

// -------------------------------------------------------------------

// DefaultMessage

// .serverMessageSystem.CommonHeader header = 1;
inline bool DefaultMessage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DefaultMessage::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& DefaultMessage::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& DefaultMessage::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.DefaultMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* DefaultMessage::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.DefaultMessage.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* DefaultMessage::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.DefaultMessage.header)
  return header_;
}
inline void DefaultMessage::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.DefaultMessage.header)
}

// .serverMessageSystem.ChartSubSysCommandsID chartCmdID = 2;
inline void DefaultMessage::clear_chartcmdid() {
  chartcmdid_ = 0;
}
inline ::serverMessageSystem::ChartSubSysCommandsID DefaultMessage::chartcmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.DefaultMessage.chartCmdID)
  return static_cast< ::serverMessageSystem::ChartSubSysCommandsID >(chartcmdid_);
}
inline void DefaultMessage::set_chartcmdid(::serverMessageSystem::ChartSubSysCommandsID value) {
  
  chartcmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.DefaultMessage.chartCmdID)
}

// -------------------------------------------------------------------

// ServerRoomChangesInSelectableList

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerRoomChangesInSelectableList::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerRoomChangesInSelectableList::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerRoomChangesInSelectableList::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerRoomChangesInSelectableList::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerRoomChangesInSelectableList.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerRoomChangesInSelectableList::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerRoomChangesInSelectableList.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerRoomChangesInSelectableList::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerRoomChangesInSelectableList.header)
  return header_;
}
inline void ServerRoomChangesInSelectableList::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerRoomChangesInSelectableList.header)
}

// bool deletedOrUpdateFlag = 2;
inline void ServerRoomChangesInSelectableList::clear_deletedorupdateflag() {
  deletedorupdateflag_ = false;
}
inline bool ServerRoomChangesInSelectableList::deletedorupdateflag() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerRoomChangesInSelectableList.deletedOrUpdateFlag)
  return deletedorupdateflag_;
}
inline void ServerRoomChangesInSelectableList::set_deletedorupdateflag(bool value) {
  
  deletedorupdateflag_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerRoomChangesInSelectableList.deletedOrUpdateFlag)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 3;
inline void ServerRoomChangesInSelectableList::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerRoomChangesInSelectableList::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerRoomChangesInSelectableList.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerRoomChangesInSelectableList::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerRoomChangesInSelectableList.connectionCmdID)
}

// .serverMessageSystem.CreatedRoom room = 4;
inline bool ServerRoomChangesInSelectableList::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ServerRoomChangesInSelectableList::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::serverMessageSystem::CreatedRoom& ServerRoomChangesInSelectableList::_internal_room() const {
  return *room_;
}
inline const ::serverMessageSystem::CreatedRoom& ServerRoomChangesInSelectableList::room() const {
  const ::serverMessageSystem::CreatedRoom* p = room_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerRoomChangesInSelectableList.room)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CreatedRoom*>(
      &::serverMessageSystem::_CreatedRoom_default_instance_);
}
inline ::serverMessageSystem::CreatedRoom* ServerRoomChangesInSelectableList::release_room() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerRoomChangesInSelectableList.room)
  
  ::serverMessageSystem::CreatedRoom* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CreatedRoom* ServerRoomChangesInSelectableList::mutable_room() {
  
  if (room_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CreatedRoom>(GetArenaNoVirtual());
    room_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerRoomChangesInSelectableList.room)
  return room_;
}
inline void ServerRoomChangesInSelectableList::set_allocated_room(::serverMessageSystem::CreatedRoom* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerRoomChangesInSelectableList.room)
}

// -------------------------------------------------------------------

// ClientWantedToEnterTheRoom

// .serverMessageSystem.CommonHeader header = 1;
inline bool ClientWantedToEnterTheRoom::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ClientWantedToEnterTheRoom::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ClientWantedToEnterTheRoom::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ClientWantedToEnterTheRoom::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientWantedToEnterTheRoom.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ClientWantedToEnterTheRoom::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientWantedToEnterTheRoom.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ClientWantedToEnterTheRoom::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientWantedToEnterTheRoom.header)
  return header_;
}
inline void ClientWantedToEnterTheRoom::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientWantedToEnterTheRoom.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ClientWantedToEnterTheRoom::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ClientWantedToEnterTheRoom::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientWantedToEnterTheRoom.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ClientWantedToEnterTheRoom::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientWantedToEnterTheRoom.connectionCmdID)
}

// string clientName = 3;
inline void ClientWantedToEnterTheRoom::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientWantedToEnterTheRoom::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
  return clientname_.GetNoArena();
}
inline void ClientWantedToEnterTheRoom::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
}
#if LANG_CXX11
inline void ClientWantedToEnterTheRoom::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
}
#endif
inline void ClientWantedToEnterTheRoom::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
}
inline void ClientWantedToEnterTheRoom::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
}
inline ::std::string* ClientWantedToEnterTheRoom::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientWantedToEnterTheRoom::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientWantedToEnterTheRoom::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ClientWantedToEnterTheRoom.clientName)
}

// uint32 roomID = 4;
inline void ClientWantedToEnterTheRoom::clear_roomid() {
  roomid_ = 0u;
}
inline ::google::protobuf::uint32 ClientWantedToEnterTheRoom::roomid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ClientWantedToEnterTheRoom.roomID)
  return roomid_;
}
inline void ClientWantedToEnterTheRoom::set_roomid(::google::protobuf::uint32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ClientWantedToEnterTheRoom.roomID)
}

// -------------------------------------------------------------------

// ServerClientWantedToEnterTheRoomReply

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerClientWantedToEnterTheRoomReply::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerClientWantedToEnterTheRoomReply::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerClientWantedToEnterTheRoomReply::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerClientWantedToEnterTheRoomReply::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerClientWantedToEnterTheRoomReply::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerClientWantedToEnterTheRoomReply::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.header)
  return header_;
}
inline void ServerClientWantedToEnterTheRoomReply::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerClientWantedToEnterTheRoomReply::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerClientWantedToEnterTheRoomReply::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerClientWantedToEnterTheRoomReply::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.connectionCmdID)
}

// bool entranceAllowed = 3;
inline void ServerClientWantedToEnterTheRoomReply::clear_entranceallowed() {
  entranceallowed_ = false;
}
inline bool ServerClientWantedToEnterTheRoomReply::entranceallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.entranceAllowed)
  return entranceallowed_;
}
inline void ServerClientWantedToEnterTheRoomReply::set_entranceallowed(bool value) {
  
  entranceallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.entranceAllowed)
}

// string masterName = 4;
inline void ServerClientWantedToEnterTheRoomReply::clear_mastername() {
  mastername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerClientWantedToEnterTheRoomReply::mastername() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
  return mastername_.GetNoArena();
}
inline void ServerClientWantedToEnterTheRoomReply::set_mastername(const ::std::string& value) {
  
  mastername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
}
#if LANG_CXX11
inline void ServerClientWantedToEnterTheRoomReply::set_mastername(::std::string&& value) {
  
  mastername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
}
#endif
inline void ServerClientWantedToEnterTheRoomReply::set_mastername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mastername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
}
inline void ServerClientWantedToEnterTheRoomReply::set_mastername(const char* value, size_t size) {
  
  mastername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
}
inline ::std::string* ServerClientWantedToEnterTheRoomReply::mutable_mastername() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
  return mastername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerClientWantedToEnterTheRoomReply::release_mastername() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
  
  return mastername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerClientWantedToEnterTheRoomReply::set_allocated_mastername(::std::string* mastername) {
  if (mastername != NULL) {
    
  } else {
    
  }
  mastername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mastername);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.masterName)
}

// .serverMessageSystem.CreatedRoom room = 5;
inline bool ServerClientWantedToEnterTheRoomReply::has_room() const {
  return this != internal_default_instance() && room_ != NULL;
}
inline void ServerClientWantedToEnterTheRoomReply::clear_room() {
  if (GetArenaNoVirtual() == NULL && room_ != NULL) {
    delete room_;
  }
  room_ = NULL;
}
inline const ::serverMessageSystem::CreatedRoom& ServerClientWantedToEnterTheRoomReply::_internal_room() const {
  return *room_;
}
inline const ::serverMessageSystem::CreatedRoom& ServerClientWantedToEnterTheRoomReply::room() const {
  const ::serverMessageSystem::CreatedRoom* p = room_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.room)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CreatedRoom*>(
      &::serverMessageSystem::_CreatedRoom_default_instance_);
}
inline ::serverMessageSystem::CreatedRoom* ServerClientWantedToEnterTheRoomReply::release_room() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.room)
  
  ::serverMessageSystem::CreatedRoom* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CreatedRoom* ServerClientWantedToEnterTheRoomReply::mutable_room() {
  
  if (room_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CreatedRoom>(GetArenaNoVirtual());
    room_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.room)
  return room_;
}
inline void ServerClientWantedToEnterTheRoomReply::set_allocated_room(::serverMessageSystem::CreatedRoom* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.room)
}

// .serverMessageSystem.GameSettings settings = 6;
inline bool ServerClientWantedToEnterTheRoomReply::has_settings() const {
  return this != internal_default_instance() && settings_ != NULL;
}
inline void ServerClientWantedToEnterTheRoomReply::clear_settings() {
  if (GetArenaNoVirtual() == NULL && settings_ != NULL) {
    delete settings_;
  }
  settings_ = NULL;
}
inline const ::serverMessageSystem::GameSettings& ServerClientWantedToEnterTheRoomReply::_internal_settings() const {
  return *settings_;
}
inline const ::serverMessageSystem::GameSettings& ServerClientWantedToEnterTheRoomReply::settings() const {
  const ::serverMessageSystem::GameSettings* p = settings_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.settings)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::GameSettings*>(
      &::serverMessageSystem::_GameSettings_default_instance_);
}
inline ::serverMessageSystem::GameSettings* ServerClientWantedToEnterTheRoomReply::release_settings() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.settings)
  
  ::serverMessageSystem::GameSettings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline ::serverMessageSystem::GameSettings* ServerClientWantedToEnterTheRoomReply::mutable_settings() {
  
  if (settings_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::GameSettings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.settings)
  return settings_;
}
inline void ServerClientWantedToEnterTheRoomReply::set_allocated_settings(::serverMessageSystem::GameSettings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete settings_;
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerClientWantedToEnterTheRoomReply.settings)
}

// -------------------------------------------------------------------

// ServerReportsClientIsLeaving

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerReportsClientIsLeaving::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerReportsClientIsLeaving::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerReportsClientIsLeaving::_internal_header() const {
  return *header_;
}
inline const ::serverMessageSystem::CommonHeader& ServerReportsClientIsLeaving::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsClientIsLeaving.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerReportsClientIsLeaving::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerReportsClientIsLeaving.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerReportsClientIsLeaving::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerReportsClientIsLeaving.header)
  return header_;
}
inline void ServerReportsClientIsLeaving::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerReportsClientIsLeaving.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerReportsClientIsLeaving::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerReportsClientIsLeaving::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsClientIsLeaving.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerReportsClientIsLeaving::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsClientIsLeaving.connectionCmdID)
}

// uint32 socketDescriptor = 3;
inline void ServerReportsClientIsLeaving::clear_socketdescriptor() {
  socketdescriptor_ = 0u;
}
inline ::google::protobuf::uint32 ServerReportsClientIsLeaving::socketdescriptor() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsClientIsLeaving.socketDescriptor)
  return socketdescriptor_;
}
inline void ServerReportsClientIsLeaving::set_socketdescriptor(::google::protobuf::uint32 value) {
  
  socketdescriptor_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsClientIsLeaving.socketDescriptor)
}

// string clientName = 4;
inline void ServerReportsClientIsLeaving::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerReportsClientIsLeaving::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
  return clientname_.GetNoArena();
}
inline void ServerReportsClientIsLeaving::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
}
#if LANG_CXX11
inline void ServerReportsClientIsLeaving::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
}
#endif
inline void ServerReportsClientIsLeaving::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
}
inline void ServerReportsClientIsLeaving::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
}
inline ::std::string* ServerReportsClientIsLeaving::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerReportsClientIsLeaving::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerReportsClientIsLeaving::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerReportsClientIsLeaving.clientName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serverMessageSystem

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::serverMessageSystem::RulesType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::RulesType>() {
  return ::serverMessageSystem::RulesType_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::SubSystemID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::SubSystemID>() {
  return ::serverMessageSystem::SubSystemID_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::ConnectionSubSysCommandsID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::ConnectionSubSysCommandsID>() {
  return ::serverMessageSystem::ConnectionSubSysCommandsID_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::ChartSubSysCommandsID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::ChartSubSysCommandsID>() {
  return ::serverMessageSystem::ChartSubSysCommandsID_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::GameCreationRequest> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::GameCreationRequest>() {
  return ::serverMessageSystem::GameCreationRequest_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_serverMessageSystem_2eproto
