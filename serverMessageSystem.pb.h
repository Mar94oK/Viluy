// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serverMessageSystem.proto

#ifndef PROTOBUF_INCLUDED_serverMessageSystem_2eproto
#define PROTOBUF_INCLUDED_serverMessageSystem_2eproto
#undef PROTOBUF_DEPRECATED
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3006001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_serverMessageSystem_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_serverMessageSystem_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_serverMessageSystem_2eproto();
namespace serverMessageSystem {
class CommonHeader;
class CommonHeaderDefaultTypeInternal;
extern CommonHeaderDefaultTypeInternal _CommonHeader_default_instance_;
class GameSettings;
class GameSettingsDefaultTypeInternal;
extern GameSettingsDefaultTypeInternal _GameSettings_default_instance_;
class GameType;
class GameTypeDefaultTypeInternal;
extern GameTypeDefaultTypeInternal _GameType_default_instance_;
class RoomCreationErrors;
class RoomCreationErrorsDefaultTypeInternal;
extern RoomCreationErrorsDefaultTypeInternal _RoomCreationErrors_default_instance_;
class ServerInputQuery;
class ServerInputQueryDefaultTypeInternal;
extern ServerInputQueryDefaultTypeInternal _ServerInputQuery_default_instance_;
class ServerQueryReply;
class ServerQueryReplyDefaultTypeInternal;
extern ServerQueryReplyDefaultTypeInternal _ServerQueryReply_default_instance_;
class TimeSettings;
class TimeSettingsDefaultTypeInternal;
extern TimeSettingsDefaultTypeInternal _TimeSettings_default_instance_;
}  // namespace serverMessageSystem
namespace google {
namespace protobuf {
template<> ::serverMessageSystem::CommonHeader* Arena::CreateMaybeMessage<::serverMessageSystem::CommonHeader>(Arena*);
template<> ::serverMessageSystem::GameSettings* Arena::CreateMaybeMessage<::serverMessageSystem::GameSettings>(Arena*);
template<> ::serverMessageSystem::GameType* Arena::CreateMaybeMessage<::serverMessageSystem::GameType>(Arena*);
template<> ::serverMessageSystem::RoomCreationErrors* Arena::CreateMaybeMessage<::serverMessageSystem::RoomCreationErrors>(Arena*);
template<> ::serverMessageSystem::ServerInputQuery* Arena::CreateMaybeMessage<::serverMessageSystem::ServerInputQuery>(Arena*);
template<> ::serverMessageSystem::ServerQueryReply* Arena::CreateMaybeMessage<::serverMessageSystem::ServerQueryReply>(Arena*);
template<> ::serverMessageSystem::TimeSettings* Arena::CreateMaybeMessage<::serverMessageSystem::TimeSettings>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace serverMessageSystem {

enum RulesType {
  Automatic = 0,
  Manual = 1,
  RulesType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RulesType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RulesType_IsValid(int value);
const RulesType RulesType_MIN = Automatic;
const RulesType RulesType_MAX = Manual;
const int RulesType_ARRAYSIZE = RulesType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RulesType_descriptor();
inline const ::std::string& RulesType_Name(RulesType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RulesType_descriptor(), value);
}
inline bool RulesType_Parse(
    const ::std::string& name, RulesType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RulesType>(
    RulesType_descriptor(), name, value);
}
enum SubSystemID {
  CONNECTION_SUBSYSTEM = 0,
  GAME_ACTIONS_SUBSYSTEM = 1,
  GAME_NOTIFICATION_SUBSYSTEM = 2,
  SubSystemID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SubSystemID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SubSystemID_IsValid(int value);
const SubSystemID SubSystemID_MIN = CONNECTION_SUBSYSTEM;
const SubSystemID SubSystemID_MAX = GAME_NOTIFICATION_SUBSYSTEM;
const int SubSystemID_ARRAYSIZE = SubSystemID_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubSystemID_descriptor();
inline const ::std::string& SubSystemID_Name(SubSystemID value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubSystemID_descriptor(), value);
}
inline bool SubSystemID_Parse(
    const ::std::string& name, SubSystemID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubSystemID>(
    SubSystemID_descriptor(), name, value);
}
enum ConnectionSubSysCommandsID {
  SERVER_INPUT_QUERY_REQUEST = 0,
  SERVER_INPUT_QUERY_REPLY = 1,
  CLIENT_ROOM_CREATION_REQUEST = 2,
  CLIENT_ROOM_CREATION_REPLY = 3,
  CLIENT_CONNECTION_TO_ROOM_REQUEST = 4,
  CLIENT_CONNECTION_TO_ROOM_REPLY = 5,
  ConnectionSubSysCommandsID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConnectionSubSysCommandsID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConnectionSubSysCommandsID_IsValid(int value);
const ConnectionSubSysCommandsID ConnectionSubSysCommandsID_MIN = SERVER_INPUT_QUERY_REQUEST;
const ConnectionSubSysCommandsID ConnectionSubSysCommandsID_MAX = CLIENT_CONNECTION_TO_ROOM_REPLY;
const int ConnectionSubSysCommandsID_ARRAYSIZE = ConnectionSubSysCommandsID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionSubSysCommandsID_descriptor();
inline const ::std::string& ConnectionSubSysCommandsID_Name(ConnectionSubSysCommandsID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionSubSysCommandsID_descriptor(), value);
}
inline bool ConnectionSubSysCommandsID_Parse(
    const ::std::string& name, ConnectionSubSysCommandsID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionSubSysCommandsID>(
    ConnectionSubSysCommandsID_descriptor(), name, value);
}
enum GameCreationRequest {
  JoinTheGame = 0,
  CreateTheGame = 1,
  GameCreationRequest_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  GameCreationRequest_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool GameCreationRequest_IsValid(int value);
const GameCreationRequest GameCreationRequest_MIN = JoinTheGame;
const GameCreationRequest GameCreationRequest_MAX = CreateTheGame;
const int GameCreationRequest_ARRAYSIZE = GameCreationRequest_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameCreationRequest_descriptor();
inline const ::std::string& GameCreationRequest_Name(GameCreationRequest value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameCreationRequest_descriptor(), value);
}
inline bool GameCreationRequest_Parse(
    const ::std::string& name, GameCreationRequest* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameCreationRequest>(
    GameCreationRequest_descriptor(), name, value);
}
// ===================================================================

class CommonHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.CommonHeader) */ {
 public:
  CommonHeader();
  virtual ~CommonHeader();

  CommonHeader(const CommonHeader& from);

  inline CommonHeader& operator=(const CommonHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonHeader(CommonHeader&& from) noexcept
    : CommonHeader() {
    *this = ::std::move(from);
  }

  inline CommonHeader& operator=(CommonHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CommonHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonHeader* internal_default_instance() {
    return reinterpret_cast<const CommonHeader*>(
               &_CommonHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CommonHeader* other);
  friend void swap(CommonHeader& a, CommonHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonHeader* New() const final {
    return CreateMaybeMessage<CommonHeader>(NULL);
  }

  CommonHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonHeader& from);
  void MergeFrom(const CommonHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.SubSystemID subSystem = 1;
  void clear_subsystem();
  static const int kSubSystemFieldNumber = 1;
  ::serverMessageSystem::SubSystemID subsystem() const;
  void set_subsystem(::serverMessageSystem::SubSystemID value);

  // uint32 commandId = 2;
  void clear_commandid();
  static const int kCommandIdFieldNumber = 2;
  ::google::protobuf::uint32 commandid() const;
  void set_commandid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.CommonHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int subsystem_;
  ::google::protobuf::uint32 commandid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class TimeSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.TimeSettings) */ {
 public:
  TimeSettings();
  virtual ~TimeSettings();

  TimeSettings(const TimeSettings& from);

  inline TimeSettings& operator=(const TimeSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeSettings(TimeSettings&& from) noexcept
    : TimeSettings() {
    *this = ::std::move(from);
  }

  inline TimeSettings& operator=(TimeSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TimeSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeSettings* internal_default_instance() {
    return reinterpret_cast<const TimeSettings*>(
               &_TimeSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TimeSettings* other);
  friend void swap(TimeSettings& a, TimeSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeSettings* New() const final {
    return CreateMaybeMessage<TimeSettings>(NULL);
  }

  TimeSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeSettings& from);
  void MergeFrom(const TimeSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 totalTimeToMove = 1;
  void clear_totaltimetomove();
  static const int kTotalTimeToMoveFieldNumber = 1;
  ::google::protobuf::uint32 totaltimetomove() const;
  void set_totaltimetomove(::google::protobuf::uint32 value);

  // uint32 timeToThink = 2;
  void clear_timetothink();
  static const int kTimeToThinkFieldNumber = 2;
  ::google::protobuf::uint32 timetothink() const;
  void set_timetothink(::google::protobuf::uint32 value);

  // uint32 timeForOpponentsDecision = 3;
  void clear_timeforopponentsdecision();
  static const int kTimeForOpponentsDecisionFieldNumber = 3;
  ::google::protobuf::uint32 timeforopponentsdecision() const;
  void set_timeforopponentsdecision(::google::protobuf::uint32 value);

  // uint32 diplomacyTime = 4;
  void clear_diplomacytime();
  static const int kDiplomacyTimeFieldNumber = 4;
  ::google::protobuf::uint32 diplomacytime() const;
  void set_diplomacytime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.TimeSettings)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 totaltimetomove_;
  ::google::protobuf::uint32 timetothink_;
  ::google::protobuf::uint32 timeforopponentsdecision_;
  ::google::protobuf::uint32 diplomacytime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class GameType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.GameType) */ {
 public:
  GameType();
  virtual ~GameType();

  GameType(const GameType& from);

  inline GameType& operator=(const GameType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameType(GameType&& from) noexcept
    : GameType() {
    *this = ::std::move(from);
  }

  inline GameType& operator=(GameType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameType* internal_default_instance() {
    return reinterpret_cast<const GameType*>(
               &_GameType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GameType* other);
  friend void swap(GameType& a, GameType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameType* New() const final {
    return CreateMaybeMessage<GameType>(NULL);
  }

  GameType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameType& from);
  void MergeFrom(const GameType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool hasAddonWildAxe = 1;
  void clear_hasaddonwildaxe();
  static const int kHasAddonWildAxeFieldNumber = 1;
  bool hasaddonwildaxe() const;
  void set_hasaddonwildaxe(bool value);

  // bool hasAddonClericalErrors = 2;
  void clear_hasaddonclericalerrors();
  static const int kHasAddonClericalErrorsFieldNumber = 2;
  bool hasaddonclericalerrors() const;
  void set_hasaddonclericalerrors(bool value);

  // .serverMessageSystem.RulesType rulesType = 3;
  void clear_rulestype();
  static const int kRulesTypeFieldNumber = 3;
  ::serverMessageSystem::RulesType rulestype() const;
  void set_rulestype(::serverMessageSystem::RulesType value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.GameType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool hasaddonwildaxe_;
  bool hasaddonclericalerrors_;
  int rulestype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class GameSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.GameSettings) */ {
 public:
  GameSettings();
  virtual ~GameSettings();

  GameSettings(const GameSettings& from);

  inline GameSettings& operator=(const GameSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameSettings(GameSettings&& from) noexcept
    : GameSettings() {
    *this = ::std::move(from);
  }

  inline GameSettings& operator=(GameSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameSettings* internal_default_instance() {
    return reinterpret_cast<const GameSettings*>(
               &_GameSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GameSettings* other);
  friend void swap(GameSettings& a, GameSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameSettings* New() const final {
    return CreateMaybeMessage<GameSettings>(NULL);
  }

  GameSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameSettings& from);
  void MergeFrom(const GameSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .serverMessageSystem.GameType gameType = 1;
  bool has_gametype() const;
  void clear_gametype();
  static const int kGameTypeFieldNumber = 1;
  const ::serverMessageSystem::GameType& gametype() const;
  ::serverMessageSystem::GameType* release_gametype();
  ::serverMessageSystem::GameType* mutable_gametype();
  void set_allocated_gametype(::serverMessageSystem::GameType* gametype);

  // .serverMessageSystem.TimeSettings timeSettings = 2;
  bool has_timesettings() const;
  void clear_timesettings();
  static const int kTimeSettingsFieldNumber = 2;
  const ::serverMessageSystem::TimeSettings& timesettings() const;
  ::serverMessageSystem::TimeSettings* release_timesettings();
  ::serverMessageSystem::TimeSettings* mutable_timesettings();
  void set_allocated_timesettings(::serverMessageSystem::TimeSettings* timesettings);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.GameSettings)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::serverMessageSystem::GameType* gametype_;
  ::serverMessageSystem::TimeSettings* timesettings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class RoomCreationErrors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.RoomCreationErrors) */ {
 public:
  RoomCreationErrors();
  virtual ~RoomCreationErrors();

  RoomCreationErrors(const RoomCreationErrors& from);

  inline RoomCreationErrors& operator=(const RoomCreationErrors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomCreationErrors(RoomCreationErrors&& from) noexcept
    : RoomCreationErrors() {
    *this = ::std::move(from);
  }

  inline RoomCreationErrors& operator=(RoomCreationErrors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RoomCreationErrors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomCreationErrors* internal_default_instance() {
    return reinterpret_cast<const RoomCreationErrors*>(
               &_RoomCreationErrors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RoomCreationErrors* other);
  friend void swap(RoomCreationErrors& a, RoomCreationErrors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomCreationErrors* New() const final {
    return CreateMaybeMessage<RoomCreationErrors>(NULL);
  }

  RoomCreationErrors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomCreationErrors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomCreationErrors& from);
  void MergeFrom(const RoomCreationErrors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreationErrors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool noFreeSlotsAvailable = 1;
  void clear_nofreeslotsavailable();
  static const int kNoFreeSlotsAvailableFieldNumber = 1;
  bool nofreeslotsavailable() const;
  void set_nofreeslotsavailable(bool value);

  // bool rulesAreNotSupported = 2;
  void clear_rulesarenotsupported();
  static const int kRulesAreNotSupportedFieldNumber = 2;
  bool rulesarenotsupported() const;
  void set_rulesarenotsupported(bool value);

  // bool incorrectSettings = 3;
  void clear_incorrectsettings();
  static const int kIncorrectSettingsFieldNumber = 3;
  bool incorrectsettings() const;
  void set_incorrectsettings(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.RoomCreationErrors)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool nofreeslotsavailable_;
  bool rulesarenotsupported_;
  bool incorrectsettings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class ServerInputQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerInputQuery) */ {
 public:
  ServerInputQuery();
  virtual ~ServerInputQuery();

  ServerInputQuery(const ServerInputQuery& from);

  inline ServerInputQuery& operator=(const ServerInputQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInputQuery(ServerInputQuery&& from) noexcept
    : ServerInputQuery() {
    *this = ::std::move(from);
  }

  inline ServerInputQuery& operator=(ServerInputQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ServerInputQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInputQuery* internal_default_instance() {
    return reinterpret_cast<const ServerInputQuery*>(
               &_ServerInputQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ServerInputQuery* other);
  friend void swap(ServerInputQuery& a, ServerInputQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInputQuery* New() const final {
    return CreateMaybeMessage<ServerInputQuery>(NULL);
  }

  ServerInputQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerInputQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerInputQuery& from);
  void MergeFrom(const ServerInputQuery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInputQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientName = 3;
  void clear_clientname();
  static const int kClientNameFieldNumber = 3;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  #if LANG_CXX11
  void set_clientname(::std::string&& value);
  #endif
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // string OsType = 4;
  void clear_ostype();
  static const int kOsTypeFieldNumber = 4;
  const ::std::string& ostype() const;
  void set_ostype(const ::std::string& value);
  #if LANG_CXX11
  void set_ostype(::std::string&& value);
  #endif
  void set_ostype(const char* value);
  void set_ostype(const char* value, size_t size);
  ::std::string* mutable_ostype();
  ::std::string* release_ostype();
  void set_allocated_ostype(::std::string* ostype);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerInputQuery)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  ::google::protobuf::internal::ArenaStringPtr ostype_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// -------------------------------------------------------------------

class ServerQueryReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:serverMessageSystem.ServerQueryReply) */ {
 public:
  ServerQueryReply();
  virtual ~ServerQueryReply();

  ServerQueryReply(const ServerQueryReply& from);

  inline ServerQueryReply& operator=(const ServerQueryReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerQueryReply(ServerQueryReply&& from) noexcept
    : ServerQueryReply() {
    *this = ::std::move(from);
  }

  inline ServerQueryReply& operator=(ServerQueryReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ServerQueryReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerQueryReply* internal_default_instance() {
    return reinterpret_cast<const ServerQueryReply*>(
               &_ServerQueryReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ServerQueryReply* other);
  friend void swap(ServerQueryReply& a, ServerQueryReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerQueryReply* New() const final {
    return CreateMaybeMessage<ServerQueryReply>(NULL);
  }

  ServerQueryReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerQueryReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerQueryReply& from);
  void MergeFrom(const ServerQueryReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerQueryReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string serverName = 5;
  void clear_servername();
  static const int kServerNameFieldNumber = 5;
  const ::std::string& servername() const;
  void set_servername(const ::std::string& value);
  #if LANG_CXX11
  void set_servername(::std::string&& value);
  #endif
  void set_servername(const char* value);
  void set_servername(const char* value, size_t size);
  ::std::string* mutable_servername();
  ::std::string* release_servername();
  void set_allocated_servername(::std::string* servername);

  // .serverMessageSystem.CommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::serverMessageSystem::CommonHeader& header() const;
  ::serverMessageSystem::CommonHeader* release_header();
  ::serverMessageSystem::CommonHeader* mutable_header();
  void set_allocated_header(::serverMessageSystem::CommonHeader* header);

  // .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
  void clear_connectioncmdid();
  static const int kConnectionCmdIDFieldNumber = 2;
  ::serverMessageSystem::ConnectionSubSysCommandsID connectioncmdid() const;
  void set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value);

  // bool roomCreationAllowed = 3;
  void clear_roomcreationallowed();
  static const int kRoomCreationAllowedFieldNumber = 3;
  bool roomcreationallowed() const;
  void set_roomcreationallowed(bool value);

  // bool connectionToRoomAllowed = 4;
  void clear_connectiontoroomallowed();
  static const int kConnectionToRoomAllowedFieldNumber = 4;
  bool connectiontoroomallowed() const;
  void set_connectiontoroomallowed(bool value);

  // @@protoc_insertion_point(class_scope:serverMessageSystem.ServerQueryReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::serverMessageSystem::CommonHeader* header_;
  int connectioncmdid_;
  bool roomcreationallowed_;
  bool connectiontoroomallowed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_serverMessageSystem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonHeader

// .serverMessageSystem.SubSystemID subSystem = 1;
inline void CommonHeader::clear_subsystem() {
  subsystem_ = 0;
}
inline ::serverMessageSystem::SubSystemID CommonHeader::subsystem() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CommonHeader.subSystem)
  return static_cast< ::serverMessageSystem::SubSystemID >(subsystem_);
}
inline void CommonHeader::set_subsystem(::serverMessageSystem::SubSystemID value) {
  
  subsystem_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CommonHeader.subSystem)
}

// uint32 commandId = 2;
inline void CommonHeader::clear_commandid() {
  commandid_ = 0u;
}
inline ::google::protobuf::uint32 CommonHeader::commandid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.CommonHeader.commandId)
  return commandid_;
}
inline void CommonHeader::set_commandid(::google::protobuf::uint32 value) {
  
  commandid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.CommonHeader.commandId)
}

// -------------------------------------------------------------------

// TimeSettings

// uint32 totalTimeToMove = 1;
inline void TimeSettings::clear_totaltimetomove() {
  totaltimetomove_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::totaltimetomove() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.totalTimeToMove)
  return totaltimetomove_;
}
inline void TimeSettings::set_totaltimetomove(::google::protobuf::uint32 value) {
  
  totaltimetomove_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.totalTimeToMove)
}

// uint32 timeToThink = 2;
inline void TimeSettings::clear_timetothink() {
  timetothink_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::timetothink() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.timeToThink)
  return timetothink_;
}
inline void TimeSettings::set_timetothink(::google::protobuf::uint32 value) {
  
  timetothink_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.timeToThink)
}

// uint32 timeForOpponentsDecision = 3;
inline void TimeSettings::clear_timeforopponentsdecision() {
  timeforopponentsdecision_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::timeforopponentsdecision() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.timeForOpponentsDecision)
  return timeforopponentsdecision_;
}
inline void TimeSettings::set_timeforopponentsdecision(::google::protobuf::uint32 value) {
  
  timeforopponentsdecision_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.timeForOpponentsDecision)
}

// uint32 diplomacyTime = 4;
inline void TimeSettings::clear_diplomacytime() {
  diplomacytime_ = 0u;
}
inline ::google::protobuf::uint32 TimeSettings::diplomacytime() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.TimeSettings.diplomacyTime)
  return diplomacytime_;
}
inline void TimeSettings::set_diplomacytime(::google::protobuf::uint32 value) {
  
  diplomacytime_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.TimeSettings.diplomacyTime)
}

// -------------------------------------------------------------------

// GameType

// bool hasAddonWildAxe = 1;
inline void GameType::clear_hasaddonwildaxe() {
  hasaddonwildaxe_ = false;
}
inline bool GameType::hasaddonwildaxe() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.hasAddonWildAxe)
  return hasaddonwildaxe_;
}
inline void GameType::set_hasaddonwildaxe(bool value) {
  
  hasaddonwildaxe_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.hasAddonWildAxe)
}

// bool hasAddonClericalErrors = 2;
inline void GameType::clear_hasaddonclericalerrors() {
  hasaddonclericalerrors_ = false;
}
inline bool GameType::hasaddonclericalerrors() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.hasAddonClericalErrors)
  return hasaddonclericalerrors_;
}
inline void GameType::set_hasaddonclericalerrors(bool value) {
  
  hasaddonclericalerrors_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.hasAddonClericalErrors)
}

// .serverMessageSystem.RulesType rulesType = 3;
inline void GameType::clear_rulestype() {
  rulestype_ = 0;
}
inline ::serverMessageSystem::RulesType GameType::rulestype() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameType.rulesType)
  return static_cast< ::serverMessageSystem::RulesType >(rulestype_);
}
inline void GameType::set_rulestype(::serverMessageSystem::RulesType value) {
  
  rulestype_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.GameType.rulesType)
}

// -------------------------------------------------------------------

// GameSettings

// .serverMessageSystem.GameType gameType = 1;
inline bool GameSettings::has_gametype() const {
  return this != internal_default_instance() && gametype_ != NULL;
}
inline void GameSettings::clear_gametype() {
  if (GetArenaNoVirtual() == NULL && gametype_ != NULL) {
    delete gametype_;
  }
  gametype_ = NULL;
}
inline const ::serverMessageSystem::GameType& GameSettings::gametype() const {
  const ::serverMessageSystem::GameType* p = gametype_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.gameType)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::GameType*>(
      &::serverMessageSystem::_GameType_default_instance_);
}
inline ::serverMessageSystem::GameType* GameSettings::release_gametype() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.GameSettings.gameType)
  
  ::serverMessageSystem::GameType* temp = gametype_;
  gametype_ = NULL;
  return temp;
}
inline ::serverMessageSystem::GameType* GameSettings::mutable_gametype() {
  
  if (gametype_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::GameType>(GetArenaNoVirtual());
    gametype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.GameSettings.gameType)
  return gametype_;
}
inline void GameSettings::set_allocated_gametype(::serverMessageSystem::GameType* gametype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gametype_;
  }
  if (gametype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gametype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gametype, submessage_arena);
    }
    
  } else {
    
  }
  gametype_ = gametype;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.GameSettings.gameType)
}

// .serverMessageSystem.TimeSettings timeSettings = 2;
inline bool GameSettings::has_timesettings() const {
  return this != internal_default_instance() && timesettings_ != NULL;
}
inline void GameSettings::clear_timesettings() {
  if (GetArenaNoVirtual() == NULL && timesettings_ != NULL) {
    delete timesettings_;
  }
  timesettings_ = NULL;
}
inline const ::serverMessageSystem::TimeSettings& GameSettings::timesettings() const {
  const ::serverMessageSystem::TimeSettings* p = timesettings_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.GameSettings.timeSettings)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::TimeSettings*>(
      &::serverMessageSystem::_TimeSettings_default_instance_);
}
inline ::serverMessageSystem::TimeSettings* GameSettings::release_timesettings() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.GameSettings.timeSettings)
  
  ::serverMessageSystem::TimeSettings* temp = timesettings_;
  timesettings_ = NULL;
  return temp;
}
inline ::serverMessageSystem::TimeSettings* GameSettings::mutable_timesettings() {
  
  if (timesettings_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::TimeSettings>(GetArenaNoVirtual());
    timesettings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.GameSettings.timeSettings)
  return timesettings_;
}
inline void GameSettings::set_allocated_timesettings(::serverMessageSystem::TimeSettings* timesettings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timesettings_;
  }
  if (timesettings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timesettings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timesettings, submessage_arena);
    }
    
  } else {
    
  }
  timesettings_ = timesettings;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.GameSettings.timeSettings)
}

// -------------------------------------------------------------------

// RoomCreationErrors

// bool noFreeSlotsAvailable = 1;
inline void RoomCreationErrors::clear_nofreeslotsavailable() {
  nofreeslotsavailable_ = false;
}
inline bool RoomCreationErrors::nofreeslotsavailable() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.noFreeSlotsAvailable)
  return nofreeslotsavailable_;
}
inline void RoomCreationErrors::set_nofreeslotsavailable(bool value) {
  
  nofreeslotsavailable_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.noFreeSlotsAvailable)
}

// bool rulesAreNotSupported = 2;
inline void RoomCreationErrors::clear_rulesarenotsupported() {
  rulesarenotsupported_ = false;
}
inline bool RoomCreationErrors::rulesarenotsupported() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.rulesAreNotSupported)
  return rulesarenotsupported_;
}
inline void RoomCreationErrors::set_rulesarenotsupported(bool value) {
  
  rulesarenotsupported_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.rulesAreNotSupported)
}

// bool incorrectSettings = 3;
inline void RoomCreationErrors::clear_incorrectsettings() {
  incorrectsettings_ = false;
}
inline bool RoomCreationErrors::incorrectsettings() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.RoomCreationErrors.incorrectSettings)
  return incorrectsettings_;
}
inline void RoomCreationErrors::set_incorrectsettings(bool value) {
  
  incorrectsettings_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.RoomCreationErrors.incorrectSettings)
}

// -------------------------------------------------------------------

// ServerInputQuery

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerInputQuery::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerInputQuery::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerInputQuery::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerInputQuery::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerInputQuery::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.header)
  return header_;
}
inline void ServerInputQuery::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerInputQuery::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerInputQuery::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerInputQuery::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.connectionCmdID)
}

// string clientName = 3;
inline void ServerInputQuery::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInputQuery::clientname() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.clientName)
  return clientname_.GetNoArena();
}
inline void ServerInputQuery::set_clientname(const ::std::string& value) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.clientName)
}
#if LANG_CXX11
inline void ServerInputQuery::set_clientname(::std::string&& value) {
  
  clientname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerInputQuery.clientName)
}
#endif
inline void ServerInputQuery::set_clientname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerInputQuery.clientName)
}
inline void ServerInputQuery::set_clientname(const char* value, size_t size) {
  
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerInputQuery.clientName)
}
inline ::std::string* ServerInputQuery::mutable_clientname() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInputQuery::release_clientname() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.clientName)
  
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInputQuery::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    
  } else {
    
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.clientName)
}

// string OsType = 4;
inline void ServerInputQuery::clear_ostype() {
  ostype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerInputQuery::ostype() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerInputQuery.OsType)
  return ostype_.GetNoArena();
}
inline void ServerInputQuery::set_ostype(const ::std::string& value) {
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerInputQuery.OsType)
}
#if LANG_CXX11
inline void ServerInputQuery::set_ostype(::std::string&& value) {
  
  ostype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerInputQuery.OsType)
}
#endif
inline void ServerInputQuery::set_ostype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerInputQuery.OsType)
}
inline void ServerInputQuery::set_ostype(const char* value, size_t size) {
  
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerInputQuery.OsType)
}
inline ::std::string* ServerInputQuery::mutable_ostype() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerInputQuery.OsType)
  return ostype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInputQuery::release_ostype() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerInputQuery.OsType)
  
  return ostype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInputQuery::set_allocated_ostype(::std::string* ostype) {
  if (ostype != NULL) {
    
  } else {
    
  }
  ostype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ostype);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerInputQuery.OsType)
}

// -------------------------------------------------------------------

// ServerQueryReply

// .serverMessageSystem.CommonHeader header = 1;
inline bool ServerQueryReply::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ServerQueryReply::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::serverMessageSystem::CommonHeader& ServerQueryReply::header() const {
  const ::serverMessageSystem::CommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.header)
  return p != NULL ? *p : *reinterpret_cast<const ::serverMessageSystem::CommonHeader*>(
      &::serverMessageSystem::_CommonHeader_default_instance_);
}
inline ::serverMessageSystem::CommonHeader* ServerQueryReply::release_header() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerQueryReply.header)
  
  ::serverMessageSystem::CommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::serverMessageSystem::CommonHeader* ServerQueryReply::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::serverMessageSystem::CommonHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerQueryReply.header)
  return header_;
}
inline void ServerQueryReply::set_allocated_header(::serverMessageSystem::CommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerQueryReply.header)
}

// .serverMessageSystem.ConnectionSubSysCommandsID connectionCmdID = 2;
inline void ServerQueryReply::clear_connectioncmdid() {
  connectioncmdid_ = 0;
}
inline ::serverMessageSystem::ConnectionSubSysCommandsID ServerQueryReply::connectioncmdid() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.connectionCmdID)
  return static_cast< ::serverMessageSystem::ConnectionSubSysCommandsID >(connectioncmdid_);
}
inline void ServerQueryReply::set_connectioncmdid(::serverMessageSystem::ConnectionSubSysCommandsID value) {
  
  connectioncmdid_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.connectionCmdID)
}

// bool roomCreationAllowed = 3;
inline void ServerQueryReply::clear_roomcreationallowed() {
  roomcreationallowed_ = false;
}
inline bool ServerQueryReply::roomcreationallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.roomCreationAllowed)
  return roomcreationallowed_;
}
inline void ServerQueryReply::set_roomcreationallowed(bool value) {
  
  roomcreationallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.roomCreationAllowed)
}

// bool connectionToRoomAllowed = 4;
inline void ServerQueryReply::clear_connectiontoroomallowed() {
  connectiontoroomallowed_ = false;
}
inline bool ServerQueryReply::connectiontoroomallowed() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.connectionToRoomAllowed)
  return connectiontoroomallowed_;
}
inline void ServerQueryReply::set_connectiontoroomallowed(bool value) {
  
  connectiontoroomallowed_ = value;
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.connectionToRoomAllowed)
}

// string serverName = 5;
inline void ServerQueryReply::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerQueryReply::servername() const {
  // @@protoc_insertion_point(field_get:serverMessageSystem.ServerQueryReply.serverName)
  return servername_.GetNoArena();
}
inline void ServerQueryReply::set_servername(const ::std::string& value) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:serverMessageSystem.ServerQueryReply.serverName)
}
#if LANG_CXX11
inline void ServerQueryReply::set_servername(::std::string&& value) {
  
  servername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:serverMessageSystem.ServerQueryReply.serverName)
}
#endif
inline void ServerQueryReply::set_servername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:serverMessageSystem.ServerQueryReply.serverName)
}
inline void ServerQueryReply::set_servername(const char* value, size_t size) {
  
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:serverMessageSystem.ServerQueryReply.serverName)
}
inline ::std::string* ServerQueryReply::mutable_servername() {
  
  // @@protoc_insertion_point(field_mutable:serverMessageSystem.ServerQueryReply.serverName)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerQueryReply::release_servername() {
  // @@protoc_insertion_point(field_release:serverMessageSystem.ServerQueryReply.serverName)
  
  return servername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerQueryReply::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    
  } else {
    
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:serverMessageSystem.ServerQueryReply.serverName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serverMessageSystem

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::serverMessageSystem::RulesType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::RulesType>() {
  return ::serverMessageSystem::RulesType_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::SubSystemID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::SubSystemID>() {
  return ::serverMessageSystem::SubSystemID_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::ConnectionSubSysCommandsID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::ConnectionSubSysCommandsID>() {
  return ::serverMessageSystem::ConnectionSubSysCommandsID_descriptor();
}
template <> struct is_proto_enum< ::serverMessageSystem::GameCreationRequest> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::serverMessageSystem::GameCreationRequest>() {
  return ::serverMessageSystem::GameCreationRequest_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_serverMessageSystem_2eproto
